<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Impossible Password Game (Functionality-Only)</title>
    
    <style>
        /* --- Minimal, Functional, NO-ANIMATION UI --- */
        :root {
            --color-bg: #f0f0f0;
            --color-text: #111;
            --color-card: #ffffff;
            --color-input: #f0f0f0;
            --color-border: #ccc;
            --color-highlight: #0061a4;
            --color-satisfied: #dff6dd;
            --color-satisfied-text: #0a390a;
            --color-broken: #fdebee;
            --color-broken-text: #410e0b;
            
            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-mono: "Courier New", Courier, monospace;
            
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            --border-radius: 8px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--color-bg);
            color: var(--color-text);
            font-family: var(--font-main);
            line-height: 1.6;
            padding: 1rem;
        }

        /* --- Main Layout --- */
        .container {
            max-width: 700px;
            margin: 2rem auto;
            padding: 1.5rem;
            background-color: var(--color-card);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            position: relative;
        }

        h1 {
            text-align: center;
            color: var(--color-highlight);
            margin-top: 3.5rem; 
            margin-bottom: 0.5rem;
            font-size: 2rem;
        }

        h1 .icon {
            display: inline-block;
        }

        .intro {
            text-align: center;
            color: #555;
            margin-bottom: 2rem;
            font-style: italic;
        }

        /* --- Password Input (now a Textarea) --- */
        .password-wrapper {
            position: relative;
            margin-bottom: 1rem; /* Reduced margin */
        }

        #passwordInput {
            display: block;
            width: 100%;
            min-height: 60px; /* Base height */
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            background-color: var(--color-input);
            color: var(--color-text);
            border: 2px solid var(--color-border);
            border-radius: var(--border-radius);
            font-family: var(--font-mono);
            resize: none; 
            overflow: hidden; 
            line-height: 1.6; 
            white-space: pre-wrap;
            word-break: break-all;
        }
        
        #passwordInput:disabled {
            background-color: #eee;
            color: #999;
        }

        /* --- Rule Counter --- */
        #ruleCounter {
            font-weight: bold;
            color: var(--color-highlight);
            text-align: center;
            margin-bottom: 1.5rem;
            font-size: 1.1rem;
        }

        /* --- Rules List --- */
        #rulesList {
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .rule {
            display: flex;
            align-items: flex-start;
            padding: 1rem;
            border-radius: var(--border-radius);
            border: 2px solid var(--color-border);
            opacity: 1; /* Instantly visible */
            transform: none; /* No movement */
        }
        
        .rule-number {
            font-weight: bold;
            color: var(--color-highlight);
            margin-right: 0.75rem;
            font-size: 1.1rem;
            flex-shrink: 0;
        }

        .rule-text {
            flex-grow: 1;
        }

        .rule-info {
            display: block;
            font-size: 0.9rem;
            font-style: italic;
            color: #555;
            margin-top: 0.25rem;
        }

        /* Rule States (Instant) */
        .rule.satisfied {
            background-color: var(--color-satisfied);
            border-color: #a5d6a7; 
            color: var(--color-satisfied-text);
        }
        
        .rule.satisfied .rule-number {
            color: var(--color-satisfied-text);
        }
        
        .rule.satisfied .rule-info {
            color: #388e3c;
        }

        .rule.satisfied::before {
            content: "‚úÖ";
            margin-right: 0.75rem;
            font-size: 1.2rem;
        }
        
        .rule.broken {
            background-color: var(--color-broken);
            border-color: #f5c6cb; 
            color: var(--color-broken-text);
        }
        
        .rule.broken .rule-number {
            color: #b71c1c;
        }
        
        .rule.broken .rule-info {
            color: #d32f2f;
        }

        .rule.broken::before {
            content: "‚ùå";
            margin-right: 0.75rem;
            font-size: 1.2rem;
        }
        
        /* --- Final Checkbox --- */
        #finalCheckWrapper {
            display: none; 
            margin-bottom: 1.5rem; /* Moved margin to bottom */
            padding: 1rem;
            background-color: var(--color-input);
            border-radius: var(--border-radius);
            text-align: center;
        }
        
        #finalCheckWrapper label {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--color-highlight);
            cursor: pointer;
        }
        
        #finalCheck {
            margin-right: 0.75rem;
            transform: scale(1.5);
            accent-color: var(--color-highlight);
            cursor: pointer;
        }
        
        /* --- NEW: Mud Event Reminder --- */
        #mudEventReminder {
            display: none; /* Hidden by default */
            padding: 1rem;
            margin-bottom: 1rem;
            background-color: #f5EFE6; /* A 'muddy' or 'dry' color */
            border: 2px solid #8B4513; /* Brown border */
            border-radius: var(--border-radius);
            color: #5D4037;
            font-size: 1.1rem;
            text-align: center;
            line-height: 1.5;
        }
        
        #mudEventReminder strong {
            color: #D32F2F; /* Red for the timer */
            font-size: 1.2rem;
            display: block;
            margin-top: 0.5rem;
        }

        /* --- Button Controls --- */
        #resetButton, #cheatButton {
            position: absolute;
            top: 1.5rem;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            font-weight: bold;
            border-radius: var(--border-radius);
            cursor: pointer;
            background-color: var(--color-input);
            border: 2px solid var(--color-border);
            color: var(--color-highlight);
        }

        #resetButton {
            left: 1.5rem;
        }
        #resetButton:hover {
            background-color: var(--color-broken);
            color: var(--color-broken-text);
        }
        
        #cheatButton {
            right: 1.5rem;
        }
        #cheatButton:hover {
            background-color: var(--color-satisfied);
            color: var(--color-satisfied-text);
        }

        /* --- Win State --- */
        .win-message {
            text-align: center;
            font-size: 2rem;
            color: var(--color-satisfied-text);
        }
        
        .final-password-wrapper {
            font-size: 1.25rem;
            font-weight: normal;
            color: var(--color-text);
            background-color: var(--color-input);
            padding: 1rem;
            border-radius: var(--border-radius);
            border: 2px solid var(--color-border);
            margin-top: 1.5rem;
            word-break: break-all;
            font-family: var(--font-mono);
        }
        
        /* --- Death Message --- */
        #deathMessage {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Centered */
            padding: 2rem;
            background-color: rgba(10, 10, 10, 0.95);
            color: #f44336;
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            z-index: 10000;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
        }

        /* --- Chaos Element --- */
        #chaos {
            position: fixed;
            /* top/left set by JS */
            font-size: 2rem;
            z-index: 9999;
            display: none; 
        }

        /* --- Responsive Design --- */
        @media (max-width: 600px) {
            body { padding: 0.5rem; }
            .container { margin: 0.5rem auto; padding: 1rem; }
            h1 { font-size: 1.5rem; margin-top: 4rem; }
            #passwordInput { font-size: 1rem; padding: 0.75rem 1rem; min-height: 50px; }
            .rule { padding: 0.75rem; }
            .rule-number { font-size: 1rem; margin-right: 0.5rem; }
            .rule::before { font-size: 1rem; margin-right: 0.5rem; }
            #resetButton, #cheatButton { padding: 0.25rem 0.75rem; font-size: 0.8rem; top: 1rem; }
            #resetButton { left: 1rem; }
            #cheatButton { right: 1rem; }
        }
    </style>
</head>
<body>

    <div id="chaos"></div>
    
    <div id="deathMessage"></div>

    <main class="container">
        
        <button id="resetButton">Start Over</button>
        <button id="cheatButton">Advance (Test)</button>

        <h1><span class="icon">üîí</span> The Impossible Password Game</h1>
        <p class="intro">How hard can it be? ...Right?</p>

        <div class="password-wrapper">
            <textarea id="passwordInput" placeholder="Enter password..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" rows="1"></textarea>
        </div>

        <div id="ruleCounter">0 / 75 rules satisfied</div>
        
        <div id="finalCheckWrapper">
            <label>
                <input type="checkbox" id="finalCheck">
                I've read all the rules and this is the end.
            </label>
        </div>
        
        <div id="mudEventReminder"></div>

        <ol id="rulesList"></ol>
        
    </main>

    <script>
        /**************************************************************************
         * *
         * WELCOME TO THE PASSWORD GAME JAVASCRIPT                 *
         * *
         * This is the functionality-only version. No animations.
         * *
         **************************************************************************/

        document.addEventListener('DOMContentLoaded', () => {

            // --- Helper Functions ---
            
            const isPrime = (num) => {
                if (num <= 1) return false;
                if (num <= 3) return true;
                if (num % 2 === 0 || num % 3 === 0) return false;
                for (let i = 5; i * i <= num; i = i + 6) {
                    if (num % i === 0 || num % (i + 2) === 0) return false;
                }
                return true;
            };
            
            const getZodiacSign = (date) => {
                const day = date.getDate();
                const month = date.getMonth() + 1;
                const signs = ["Capricorn", "Aquarius", "Pisces", "Aries", "Taurus", "Gemini", "Cancer", "Leo", "Virgo", "Libra", "Scorpio", "Sagittarius", "Capricorn"];
                const endDates = [19, 18, 20, 19, 20, 20, 22, 22, 22, 22, 21, 21, 19];
                return (day > endDates[month - 1]) ? signs[month] : signs[month - 1];
            };

            const reverseString = (str) => str.split("").reverse().join("");

            const totalSumAllDigits = (pass) => {
                 return (pass.match(/\d/g) || []).reduce((acc, digit) => acc + parseInt(digit, 10), 0);
            }

            // *** UPDATED findElement with ALL 118 elements ***
            const findElement = (str) => {
                const elements = {
                    "hydrogen": { "symbol": "H" },
                    "helium": { "symbol": "He" },
                    "lithium": { "symbol": "Li" },
                    "beryllium": { "symbol": "Be" },
                    "boron": { "symbol": "B" },
                    "carbon": { "symbol": "C" },
                    "nitrogen": { "symbol": "N" },
                    "oxygen": { "symbol": "O" },
                    "fluorine": { "symbol": "F" },
                    "neon": { "symbol": "Ne" },
                    "sodium": { "symbol": "Na" },
                    "magnesium": { "symbol": "Mg" },
                    "aluminium": { "symbol": "Al" },
                    "aluminum": { "symbol": "Al" },
                    "silicon": { "symbol": "Si" },
                    "phosphorus": { "symbol": "P" },
                    "sulfur": { "symbol": "S" },
                    "chlorine": { "symbol": "Cl" },
                    "argon": { "symbol": "Ar" },
                    "potassium": { "symbol": "K" },
                    "calcium": { "symbol": "Ca" },
                    "scandium": { "symbol": "Sc" },
                    "titanium": { "symbol": "Ti" },
                    "vanadium": { "symbol": "V" },
                    "chromium": { "symbol": "Cr" },
                    "manganese": { "symbol": "Mn" },
                    "iron": { "symbol": "Fe" },
                    "cobalt": { "symbol": "Co" },
                    "nickel": { "symbol": "Ni" },
                    "copper": { "symbol": "Cu" },
                    "zinc": { "symbol": "Zn" },
                    "gallium": { "symbol": "Ga" },
                    "germanium": { "symbol": "Ge" },
                    "arsenic": { "symbol": "As" },
                    "selenium": { "symbol": "Se" },
                    "bromine": { "symbol": "Br" },
                    "krypton": { "symbol": "Kr" },
                    "rubidium": { "symbol": "Rb" },
                    "strontium": { "symbol": "Sr" },
                    "yttrium": { "symbol": "Y" },
                    "zirconium": { "symbol": "Zr" },
                    "niobium": { "symbol": "Nb" },
                    "molybdenum": { "symbol": "Mo" },
                    "technetium": { "symbol": "Tc" },
                    "ruthenium": { "symbol": "Ru" },
                    "rhodium": { "symbol": "Rh" },
                    "palladium": { "symbol": "Pd" },
                    "silver": { "symbol": "Ag" },
                    "cadmium": { "symbol": "Cd" },
                    "indium": { "symbol": "In" },
                    "tin": { "symbol": "Sn" },
                    "antimony": { "symbol": "Sb" },
                    "tellurium": { "symbol": "Te" },
                    "iodine": { "symbol": "I" },
                    "xenon": { "symbol": "Xe" },
                    "caesium": { "symbol": "Cs" },
                    "cesium": { "symbol": "Cs" },
                    "barium": { "symbol": "Ba" },
                    "lanthanum": { "symbol": "La" },
                    "cerium": { "symbol": "Ce" },
                    "praseodymium": { "symbol": "Pr" },
                    "neodymium": { "symbol": "Nd" },
                    "promethium": { "symbol": "Pm" },
                    "samarium": { "symbol": "Sm" },
                    "europium": { "symbol": "Eu" },
                    "gadolinium": { "symbol": "Gd" },
                    "terbium": { "symbol": "Tb" },
                    "dysprosium": { "symbol": "Dy" },
                    "holmium": { "symbol": "Ho" },
                    "erbium": { "symbol": "Er" },
                    "thulium": { "symbol": "Tm" },
                    "ytterbium": { "symbol": "Yb" },
                    "lutetium": { "symbol": "Lu" },
                    "hafnium": { "symbol": "Hf" },
                    "tantalum": { "symbol": "Ta" },
                    "tungsten": { "symbol": "W" },
                    "rhenium": { "symbol": "Re" },
                    "osmium": { "symbol": "Os" },
                    "iridium": { "symbol": "Ir" },
                    "platinum": { "symbol": "Pt" },
                    "gold": { "symbol": "Au" },
                    "mercury": { "symbol": "Hg" },
                    "thallium": { "symbol": "Tl" },
                    "lead": { "symbol": "Pb" },
                    "bismuth": { "symbol": "Bi" },
                    "polonium": { "symbol": "Po" },
                    "astatine": { "symbol": "At" },
                    "radon": { "symbol": "Rn" },
                    "francium": { "symbol": "Fr" },
                    "radium": { "symbol": "Ra" },
                    "actinium": { "symbol": "Ac" },
                    "thorium": { "symbol": "Th" },
                    "protactinium": { "symbol": "Pa" },
                    "uranium": { "symbol": "U" },
                    "neptunium": { "symbol": "Np" },
                    "plutonium": { "symbol": "Pu" },
                    "americium": { "symbol": "Am" },
                    "curium": { "symbol": "Cm" },
                    "berkelium": { "symbol": "Bk" },
                    "californium": { "symbol": "Cf" },
                    "einsteinium": { "symbol": "Es" },
                    "fermium": { "symbol": "Fm" },
                    "mendelevium": { "symbol": "Md" },
                    "nobelium": { "symbol": "No" },
                    "lawrencium": { "symbol": "Lr" },
                    "rutherfordium": { "symbol": "Rf" },
                    "dubnium": { "symbol": "Db" },
                    "seaborgium": { "symbol": "Sg" },
                    "bohrium": { "symbol": "Bh" },
                    "hassium": { "symbol": "Hs" },
                    "meitnerium": { "symbol": "Mt" },
                    "darmstadtium": { "symbol": "Ds" },
                    "roentgenium": { "symbol": "Rg" },
                    "copernicium": { "symbol": "Cn" },
                    "nihonium": { "symbol": "Nh" },
                    "flerovium": { "symbol": "Fl" },
                    "moscovium": { "symbol": "Mc" },
                    "livermorium": { "symbol": "Lv" },
                    "tennessine": { "symbol": "Ts" },
                    "oganesson": { "symbol": "Og" }
                };
                
                const lowerPass = str.toLowerCase();
                for (const name in elements) {
                    if (lowerPass.includes(name)) {
                        return { name, symbol: elements[name].symbol };
                    }
                }
                return null;
            };

            const toRoman = (num) => {
                if (num < 1 || num > 3999) return ""; 
                const roman = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };
                let str = '';
                for (let i in roman) {
                    while (num >= roman[i]) {
                        str += i;
                        num -= roman[i];
                    }
                }
                return str;
            };
            
            const parseRoman = (str) => {
                const values = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 };
                let total = 0;
                for (let i = 0; i < str.length; i++) {
                    const current = values[str[i]];
                    const next = values[str[i + 1]];
                    
                    if (next && current < next) {
                        total -= current;
                    } else {
                        total += current;
                    }
                }
                return total;
            };

            const caesarCipher = (str, shift) => {
                return str.split('').map(char => {
                    const code = char.charCodeAt(0);
                    // Uppercase letters
                    if (code >= 65 && code <= 90) {
                        return String.fromCharCode(((code - 65 + shift) % 26) + 65);
                    }
                    // Lowercase letters
                    if (code >= 97 && code <= 122) {
                        return String.fromCharCode(((code - 97 + shift) % 26) + 97);
                    }
                    // Not a letter, return as is
                    return char;
                }).join('');
            };
            
            const resizeTextarea = () => {
                passwordInput.style.height = 'auto'; 
                passwordInput.style.height = (passwordInput.scrollHeight + 2) + 'px';
            }
            
            // --- Randomized Rule Data ---
            const secretWords = ["QRABO", "SKEEN", "ZUPPO", "FLORK", "BRYNG", "AOWKS", "EQWPS", "PYTOR", "ZAJEY", "KREEP", "WOTOK", "FYOOG", "SPOK", "GREEB", "THRAW", "YOOOP", "BAZER", "JOPPA", "GRONK", "PWYBO"];
            const carMakers = ["Abarth", "Acura", "Alfa Romeo", "Alpine", "Aston Martin", "Audi", "Bentley", "BMW", "Bugatti", "Buick", "Cadillac", "Chevrolet", "Chrysler", "Citro√´n", "Dacia", "Dodge", "Ferrari", "Fiat", "Ford", "Genesis", "GMC", "Honda", "Hyundai", "Infiniti", "Jaguar", "Jeep", "Kia", "Koenigsegg", "Lamborghini", "Land Rover", "Lexus", "Lincoln", "Lotus", "Maserati", "Mazda", "McLaren", "Mercedes-Benz", "Mini", "Mitsubishi", "Nissan", "Opel", "Peugeot", "Porsche", "Ram", "Renault", "Rolls-Royce", "Subaru", "Suzuki", "Tesla", "Toyota", "Vauxhall", "Volkswagen", "Volvo"];
            const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
            
            const atomicWords = [
                { word: "SNOW", symbols: ["S", "N", "O", "W"] },
                { word: "BOSS", symbols: ["B", "O", "S", "S"] },
                { word: "GeNiUS", symbols: ["Ge", "Ni", "U", "S"] },
                { word: "SAtUrN", symbols: ["S", "At", "U", "Rn"] },
                { word: "KNiFe", symbols: ["K", "Ni", "Fe"] },
                { word: "CaFe", symbols: ["Ca", "Fe"] }
            ];

            const allCountryCodes = ["AF","AX","AL","DZ","AS","AD","AO","AI","AQ","AG","AR","AM","AW","AU","AT","AZ","BS","BH","BD","BB","BY","BE","BZ","BJ","BM","BT","BO","BQ","BA","BW","BV","BR","IO","BN","BG","BF","BI","CV","KH","CM","CA","KY","CF","TD","CL","CN","CX","CC","CO","KM","CG","CD","CK","CR","CI","HR","CU","CW","CY","CZ","DK","DJ","DM","DO","EC","EG","SV","GQ","ER","EE","SZ","ET","FK","FO","FJ","FI","FR","GF","PF","TF","GA","GM","GE","DE","GH","GI","GR","GL","GD","GP","GU","GT","GG","GN","GW","GY","HT","HM","VA","HN","HK","HU","IS","IN","ID","IR","IQ","IE","IM","IL","IT","JM","JP","JE","JO","KZ","KE","KI","KP","KR","KW","KG","LA","LV","LB","LS","LR","LY","LI","LT","LU","MO","MG","MW","MY","MV","ML","MT","MH","MQ","MR","MU","YT","MX","FM","MD","MC","MN","ME","MS","MA","MZ","MM","NA","NR","NP","NL","NC","NZ","NI","NE","NG","NU","NF","MP","NO","OM","PK","PW","PS","PA","PG","PY","PE","PH","PN","PL","PT","PR","QA","MK","RO","RU","RW","RE","BL","SH","KN","LC","MF","PM","VC","WS","SM","ST","SA","SN","RS","SC","SL","SG","SX","SK","SI","SB","SO","ZA","GS","SS","ES","LK","SD","SR","SJ","SE","CH","SY","TW","TJ","TZ","TH","TL","TG","TK","TO","TT","TN","TR","TM","TC","TV","UG","UA","AE","GB","US","UM","UY","UZ","VU","VE","VN","VG","VI","WF","EH","YE","ZM","ZW"];
            const usStateCodes = ["AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA", "HI", "ID", "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", "NM", "NY", "NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT", "VT", "VA", "WA", "WV", "WI", "WY"];
            
            const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

            // --- List of Time-Sensitive Rule IDs ---
            const timeSensitiveRuleIds = [12, 21, 35, 36, 43, 44, 52, 56, 60];


            // --- ALL 75 RULES ARE DEFINED HERE ---

            const allRules = [
                {
                    id: 1,
                    description: "Your password must be at least 5 characters long.",
                    check: (pass, state) => pass.length >= 5
                },
                {
                    id: 2,
                    description: "Your password must include a number.",
                    check: (pass, state) => /\d/.test(pass)
                },
                {
                    id: 3,
                    description: "Your password must include an uppercase letter.",
                    check: (pass, state) => /[A-Z]/.test(pass)
                },
                {
                    id: 4,
                    description: "Your password must include a special character.",
                    check: (pass, state) => /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(pass)
                },
                {
                    id: 5,
                    description: "Your password must include the word 'password'.",
                    check: (pass, state) => pass.toLowerCase().includes("password")
                },
                {
                    id: 6,
                    description: (state) => `Your password must include a number greater than ${state.game.numGreaterThanTarget || "..."}.`,
                    check: (pass, state) => {
                        const match = pass.match(/\d+/g);
                        if (!match) return false;
                        return match.some(num => parseInt(num, 10) > state.game.numGreaterThanTarget);
                    }
                },
                {
                    id: 7,
                    description: "Your password must include an emoji.",
                    check: (pass, state) => {
                        const regex = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/;
                        return regex.test(pass);
                    }
                },
                {
                    id: 8,
                    description: "A cow says... Your password must include 'moo'.",
                    check: (pass, state) => pass.toLowerCase().includes("moo")
                },
                {
                    id: 9,
                    description: "Your password must include a common punctuation mark.",
                    check: (pass, state) => {
                         return {
                            satisfied: /[.,?!]/.test(pass),
                            info: "e.g., . , ? !"
                         };
                    }
                },
                {
                    id: 10,
                    description: "Your password must be at least 10 characters long.",
                    check: (pass, state) => pass.length >= 10
                },
                {
                    id: 11, // *** UPDATED RULE 11 ***
                    description: "Your password must include a color name.",
                    check: (pass, state) => {
                        const colors = ["red", "blue", "green", "yellow", "orange", "purple", "black", "white", "pink", "brown", "cyan", "magenta", "lime", "teal", "navy", "olive", "maroon", "silver", "gold", "aqua", "beige", "indigo", "violet"];
                        return colors.some(c => pass.toLowerCase().includes(c));
                    }
                },
                {
                    id: 12, // *** UPDATED RULE 12 (NO HINT) ***
                    description: "Your password must include the current day of the week.",
                    check: (pass, state) => {
                        const day = dayNames[new Date().getDay()];
                        return {
                            satisfied: pass.toLowerCase().includes(day.toLowerCase()),
                            info: "" // Hint removed
                        };
                    }
                },
                {
                    id: 13, // *** UPDATED RULE 13 (Lock Fix) ***
                    description: "Your password must *not* include the letter 'e'.",
                    check: (pass, state) => {
                         // *** HARD-LOCK FIX ***
                         // Rule 12 (Wednesday, Tuesday) or 37 (time) or 74 (end) or 50 (end)
                         if (state.game.activeRuleIds.includes(12) || state.game.activeRuleIds.includes(37) || state.game.activeRuleIds.includes(74) || state.game.activeRuleIds.includes(50)) {
                             return { satisfied: true, info: "Rule overridden by a later rule." };
                         }
                         return {
                            satisfied: !pass.toLowerCase().includes('e'),
                            info: "The most common letter! Good luck."
                         };
                    }
                },
                {
                    id: 14,
                    description: "Your password must include an uppercase Roman numeral.",
                    check: (pass, state) => {
                        const match = pass.match(/[IVXLCDM]/); 
                        return {
                            satisfied: !!match,
                            info: match ? `Found: ${match[0]}` : ""
                        };
                    }
                },
                {
                    id: 15,
                    description: (state) => `The uppercase Roman numerals in your password must sum to ${state.game.romanSumTarget || "..."}.`,
                    check: (pass, state) => {
                        const matches = pass.match(/[IVXLCDM]+/g) || [];
                        const sum = matches.reduce((acc, str) => acc + parseRoman(str), 0);
                        return {
                            satisfied: sum === state.game.romanSumTarget,
                            info: `Current Roman sum: ${sum}`
                        };
                    }
                },
                {
                    id: 16,
                    description: (state) => `The digits in your password must add up to ${state.game.digitSumTarget || "..."}.`,
                    check: (pass, state) => {
                        // *** HARD-LOCK FIX ***
                        if (state.game.activeRuleIds.includes(50)) {
                            return { satisfied: true, info: "Overridden by rule 50." };
                        }
                        // *** HARD-LOCK FIX ***
                        if (state.game.activeRuleIds.includes(34)) {
                             return { satisfied: true, info: "Overridden by rule 34." };
                        }
                        const totalSum = totalSumAllDigits(pass);
                        return {
                            satisfied: totalSum === state.game.digitSumTarget,
                            info: `Current sum: ${totalSum}`
                        };
                    }
                },
                {
                    id: 17,
                    description: "Your password must include a 4-letter word.",
                    check: (pass, state) => {
                        return {
                            satisfied: /\b[a-zA-Z]{4}\b/.test(pass),
                            info: "e.g., 'this' or 'word'"
                        };
                    }
                },
                {
                    id: 18,
                    description: "Your password must include a valid hex color code.",
                    check: (pass, state) => {
                        const match = pass.match(/#[0-9a-fA-F]{6}/);
                        return {
                            satisfied: !!match,
                            info: match ? `Found: ${match[0]}` : ""
                        };
                    }
                },
                {
                    id: 19,
                    description: "Your hex color must be a shade of green.",
                    check: (pass, state) => {
                        const match = pass.match(/#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})/);
                        if (!match) {
                            return { satisfied: false, info: "First satisfy rule 18." };
                        }
                        const r = parseInt(match[1], 16);
                        const g = parseInt(match[2], 16);
                        const b = parseInt(match[3], 16);
                        return {
                            satisfied: g > r && g > b && g > 100,
                            info: `Found: rgb(${r}, ${g}, ${b})`
                        };
                    }
                },
                {
                    id: 20,
                    description: (state) => `Your password must include this game's secret word: ${state.game.secretWord || "..."}`,
                    check: (pass, state) => {
                        return {
                            satisfied: pass.includes(state.game.secretWord)
                        };
                    }
                },
                {
                    id: 21,
                    description: "Your password must include the current month.",
                    check: (pass, state) => {
                        const month = monthNames[new Date().getMonth()];
                        return {
                            satisfied: pass.toLowerCase().includes(month.toLowerCase()),
                            info: ""
                        };
                    }
                },
                {
                    id: 22,
                    description: "Your password must include a 2-letter US state abbreviation.",
                    check: (pass, state) => {
                        const found = usStateCodes.find(code => pass.includes(code));
                        return {
                            satisfied: !!found,
                            info: found ? `Found: ${found}` : "e.g., CA, NY, TX"
                        };
                    }
                },
                {
                    id: 23,
                    description: "Your password must include 'password', but spelled backwards.",
                    check: (pass, state) => pass.includes("drowssap")
                },
                {
                    id: 24,
                    description: "Your password must include a zodiac sign.",
                    check: (pass, state) => {
                        const signs = ["aries", "taurus", "gemini", "cancer", "leo", "virgo", "libra", "scorpio", "sagittarius", "capricorn", "aquarius", "pisces"];
                        const found = signs.find(sign => pass.toLowerCase().includes(sign));
                        return {
                            satisfied: !!found,
                            info: ""
                        };
                    }
                },
                {
                    id: 25,
                    description: "The length of your password must be a prime number.",
                    check: (pass, state) => {
                        // *** HARD-LOCK FIX ***
                        if (state.game.activeRuleIds.includes(58)) {
                            return { satisfied: true, info: "Overridden by rule 58." };
                        }
                        return {
                            satisfied: isPrime(pass.length),
                            info: `Length: ${pass.length}`
                        };
                    }
                },
                {
                    id: 26,
                    description: "Your password must include a car manufacturer.",
                    check: (pass, state) => {
                        const found = carMakers.find(c => pass.toLowerCase().includes(c.toLowerCase()));
                        return {
                            satisfied: !!found,
                            info: found ? `Found: ${found}` : ""
                        };
                    }
                },
                {
                    id: 27,
                    description: "Your password must include two poop emojis: üí©üí©.",
                    check: (pass, state) => {
                        if (state.game.poopRulePassed) {
                            return { satisfied: true, info: "Requirement met." };
                        }
                        
                        const count = (pass.match(/üí©/g) || []).length;
                        if (count >= 2) {
                            state.game.poopRulePassed = true;
                            saveGame(); // Save persistent flag
                            return { satisfied: true, info: "Requirement met." };
                        }
                        return {
                            satisfied: false,
                            info: `Found: ${count}`
                        };
                    }
                },
                {
                    id: 28, // *** PETE LOGIC FIX ***
                    description: "Oh no! A wild üêõ has appeared... His name is Pete. Keep him safe in some soil üí©üêõüí©.",
                    check: (pass, state) => {
                        const chaosEl = document.getElementById('chaos');
                        const isSafe = pass.includes("üí©üêõüí©");

                        // --- Spawn Logic ---
                        if (!state.data.peteSpawned) {
                            state.data.peteSpawned = true;
                            chaosEl.textContent = "üêõ";
                            chaosEl.style.top = `${randomInt(10, 80)}vh`;
                            chaosEl.style.left = `${randomInt(5, 20)}vw`;
                            if (Math.random() > 0.5) {
                                chaosEl.style.left = `${randomInt(75, 90)}vw`;
                            }
                            chaosEl.style.display = "block";
                        }
                        
                        // --- Visibility & State Logic ---
                        if (isSafe) {
                            chaosEl.style.display = "none"; // Hide floating Pete
                            
                            // Set the persistent flag only once
                            if (!state.game.peteHasBeenAdded) {
                                state.game.peteHasBeenAdded = true;
                                
                                // *** NEW: Schedule the first mud event ***
                                state.game.mudEvent.nextEventTime = Date.now() + randomInt(90000, 300000); // 90-300 seconds
                                
                                saveGame(); 
                            }
                        } else {
                            // Only show floating Pete if he has *never* been added
                            if (!state.game.peteHasBeenAdded) {
                                chaosEl.style.display = "block";
                            }
                            // If he's not safe, but *has* been added before, the global
                            // check in checkRulesAndReorder will catch the deletion.
                            // The floating Pete remains hidden.
                        }
                        
                        // --- Satisfaction Logic ---
                        if (!state.game.peteHasBeenAdded) {
                            return isSafe; // Rule is only satisfied when he is first saved
                        }
                        
                        // If he has been added, the rule is permanently satisfied
                        // (as long as he's not deleted, which is caught elsewhere)
                        return { satisfied: true, info: "Pete is in your password." };
                    }
                },
                {
                    id: 29,
                    description: "Your password must contain a 'sponsored' segment.",
                    check: (pass, state) => pass.toLowerCase().includes("sponsored by")
                },
                {
                    id: 30,
                    description: "Your password must include a continent.",
                    check: (pass, state) => {
                        const continents = ["africa", "antarctica", "asia", "australia", "europe", "north america", "south america"];
                        const found = continents.find(c => pass.toLowerCase().includes(c));
                        return {
                            satisfied: !!found,
                            info: ""
                        };
                    }
                },
                {
                    id: 31,
                    description: "Your password must include an element from the periodic table.",
                    check: (pass, state) => {
                        const element = findElement(pass);
                        state.data.element = element; // Save for next rule
                        return {
                            satisfied: !!element,
                            info: element ? `Found: ${element.name}` : ""
                        };
                    }
                },
                {
                    id: 32,
                    description: "Your password must include the atomic *symbol* of that element.",
                    check: (pass, state) => {
                        const element = state.data.element; 
                        if (!element) {
                            return { satisfied: false, info: "First satisfy rule 31." };
                        }
                        return {
                            satisfied: pass.includes(element.symbol),
                            info: `Element: ${element.name} (${element.symbol})`
                        };
                    }
                },
                {
                    id: 33,
                    description: "Your password must include a true math equation.",
                    check: (pass, state) => {
                        const match = pass.match(/(\d+)\s*([+\-*/])\s*(\d+)\s*=\s*(\d+)/);
                        if (!match) {
                            return { satisfied: false, info: "e.g., 2+2=4" };
                        }
                        const n1 = parseFloat(match[1]);
                        const op = match[2];
                        const n2 = parseFloat(match[3]);
                        const n3 = parseFloat(match[4]);
                        
                        let result;
                        if (op === '+') result = n1 + n2;
                        else if (op === '-') result = n1 - n2;
                        else if (op === '*') result = n1 * n2;
                        else if (op === '/') result = n1 / n2;
                        
                        return {
                            satisfied: result === n3,
                            info: result === n3 ? `Found: ${match[0]}` : `${match[0]} is false.`
                        };
                    }
                },
                {
                    id: 34,
                    description: "The sum of all digits in your password must be odd.",
                    check: (pass, state) => {
                        const totalSum = totalSumAllDigits(pass);
                        return {
                            satisfied: totalSum > 0 && totalSum % 2 !== 0,
                            info: `Current sum: ${totalSum}`
                        };
                    }
                },
                {
                    id: 35,
                    description: "Your password must include the current hour (24-hour format).",
                    check: (pass, state) => {
                        if (state.game.activeRuleIds.includes(37)) {
                            return { satisfied: true, info: "Not needed anymore." };
                        }
                        if (state.game.activeRuleIds.includes(50)) {
                            return { satisfied: true, info: "Overridden by rule 50." };
                        }
                        const hour = new Date().getHours().toString();
                        return {
                            satisfied: pass.includes(hour),
                            info: ""
                        };
                    }
                },
                {
                    id: 36,
                    description: "Your password must include the current minute.",
                    check: (pass, state) => {
                        if (state.game.activeRuleIds.includes(37)) {
                            return { satisfied: true, info: "Not needed anymore." };
                        }
                        if (state.game.activeRuleIds.includes(50)) {
                            return { satisfied: true, info: "Overridden by rule 50." };
                        }
                        const minute = new Date().getMinutes().toString();
                        return {
                            satisfied: pass.includes(minute),
                            info: ""
                        };
                    }
                },
                {
                    id: 37,
                    description: "That was mean. Just include 'time'.",
                    check: (pass, state) => pass.toLowerCase().includes("time")
                },
                {
                    id: 38,
                    description: (state) => `Your password must include the chemical symbols in this word: **${state.game.atomicWord}**`,
                    check: (pass, state) => {
                        const symbols = state.game.atomicSymbols;
                        const satisfied = symbols.every(symbol => pass.includes(symbol));
                        return {
                            satisfied: satisfied,
                            info: "e.g., 'CaFe' requires 'Ca' and 'Fe'"
                        };
                    }
                },
                {
                    id: 39,
                    description: "Your password must include a valid YouTube video URL.",
                    check: (pass, state) => {
                        const regex = /(https?:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/(watch\?v=)?[a-zA-Z0-9_-]{11}/;
                        return regex.test(pass);
                    }
                },
                {
                    id: 40,
                    description: (state) => `Your password must contain exactly ${state.game.exclamationCount || "..."} exclamation marks.`,
                    check: (pass, state) => {
                        const count = (pass.match(/!/g) || []).length;
                        return {
                            satisfied: count === state.game.exclamationCount,
                            info: `Found: ${count}`
                        };
                    }
                },
                {
                    id: 41,
                    description: "Your password must include a two-letter country code.",
                    check: (pass, state) => {
                        const found = allCountryCodes.find(code => pass.includes(code));
                        return {
                            satisfied: !!found,
                            info: found ? `Found: ${found}` : ""
                        };
                    }
                },
                {
                    id: 42,
                    description: `Your password must contain the Konami code (letters only).`,
                    check: (pass, state) => {
                        return {
                            satisfied: pass.toLowerCase().includes("uupplrlrba"),
                            info: "e.g., up=u up=u ... b=b a=a"
                        };
                    }
                },
                {
                    id: 43,
                    description: "üå™Ô∏è A hurricane is coming! Quick, copy your password!",
                    check: (pass, state) => {
                        if (state.game.hurricaneFired) {
                            return { satisfied: true, info: "The hurricane has passed." };
                        }
                        if (!state.data.hurricaneTimerStarted) {
                            state.data.hurricaneTimerStarted = Date.now();
                        }
                        const elapsed = Date.now() - state.data.hurricaneTimerStarted;
                        const secondsLeft = 5 - Math.floor(elapsed / 1000); // 5 second timer
                        
                        if (secondsLeft > 0) {
                            return { satisfied: false, info: `Scrambling in ${secondsLeft}s...` };
                        }
                        
                        state.data.scramblePassword = true; // Flag for main loop
                        return { satisfied: false, info: "BOOM!" };
                    }
                },
                {
                    id: 44,
                    description: "The hurricane passed! But Pete is exposed! Get him back in his soil üí©üêõüí©.",
                    check: (pass, state) => {
                        if (!state.game.peteIsAlive) {
                            return { satisfied: false, info: "It's too late for Pete." };
                        }
                        
                        if (pass.includes("üí©üêõüí©")) {
                             state.data.peteTimerStarted = null; // Clear timer
                             return { satisfied: true, info: "Phew, that was close." };
                        }
                        
                        if (!state.data.peteTimerStarted) {
                            state.data.peteTimerStarted = Date.now();
                        }

                        const elapsed = Date.now() - state.data.peteTimerStarted;
                        const secondsLeft = 10 - Math.floor(elapsed / 1000);

                        if (secondsLeft > 0) {
                            return { satisfied: false, info: `Protect Pete! ${secondsLeft}s left...` };
                        }

                        gameState.peteIsAlive = false;
                        return { satisfied: false, info: "You were too slow... Pete is gone." };
                    }
                },
                {
                    id: 45,
                    description: "The number of uppercase letters must match the number of lowercase letters.",
                    check: (pass, state) => {
                        const upper = (pass.match(/[A-Z]/g) || []).length;
                        const lower = (pass.match(/[a-z]/g) || []).length;
                        return {
                            satisfied: upper > 0 && upper === lower,
                            info: `Upper: ${upper}, Lower: ${lower}`
                        };
                    }
                },
                {
                    id: 46,
                    description: "Your password must include a word at least 8 letters long.",
                    check: (pass, state) => {
                        const longWords = pass.match(/\b[a-zA-Z]{8,}\b/g) || [];
                        const found = longWords.length > 0;
                        return { satisfied: found, info: found ? `Found: ${longWords[0]}` : null };
                    }
                },
                {
                    id: 47,
                    description: "Your password must contain a major music triad.",
                    check: (pass, state) => {
                        const triads = ["C, E, G", "G, B, D", "F, A, C"];
                        const found = triads.find(t => pass.includes(t));
                        return {
                            satisfied: !!found,
                            info: found ? `Found: ${found}` : "e.g., C, E, G"
                        };
                    }
                },
                {
                    id: 48,
                    description: "Your password must include an HTML tag (e.g., &lt;p&gt;).",
                    check: (pass, state) => {
                        const match = pass.match(/<[a-zA-Z0-9]+>/);
                        return {
                            satisfied: !!match,
                            info: match ? `Found: ${match[0]}` : ""
                        };
                    }
                },
                {
                    id: 49,
                    description: "Your password must include the `<body>` HTML tag.",
                    check: (pass, state) => {
                         return {
                            satisfied: pass.includes("<body>"),
                            info: ""
                        };
                    }
                },
                {
                    id: 50,
                    description: (state) => `You must sacrifice two digits. The digits **${state.game.sacrificedDigit1}** and **${state.game.sacrificedDigit2}** may not appear.`,
                    check: (pass, state) => {
                        const d1 = state.game.sacrificedDigit1.toString();
                        const d2 = state.game.sacrificedDigit2.toString();
                        return {
                            satisfied: !pass.includes(d1) && !pass.includes(d2),
                            info: `They will not be missed.`
                        };
                    }
                },
                {
                    id: 51,
                    description: "All instances of 's' or 'S' must be replaced with '$'.",
                    check: (pass, state) => {
                        return {
                            satisfied: !pass.toLowerCase().includes('s'),
                            info: "A '$' is much cooler."
                        };
                    }
                },
                {
                    id: 52,
                    description: "Your password must include the current year.",
                    check: (pass, state) => {
                        // *** HARD-LOCK FIX ***
                        if (state.game.activeRuleIds.includes(50)) {
                            return { satisfied: true, info: "Overridden by rule 50." };
                        }
                        const year = new Date().getFullYear().toString();
                        return {
                            satisfied: pass.includes(year),
                            info: ""
                        };
                    }
                },
                {
                    id: 53,
                    description: (state) => `Your password's length must be a multiple of ${state.game.lengthMultipleTarget || "..."}.`,
                    check: (pass, state) => {
                        return {
                            satisfied: pass.length > 0 && pass.length % state.game.lengthMultipleTarget === 0,
                            info: `Length: ${pass.length}`
                        };
                    }
                },
                {
                    id: 54,
                    description: (state) => `Your password must contain the letter **${state.game.rareLetter}** at least twice.`,
                    check: (pass, state) => {
                        const letter = state.game.rareLetter;
                        const regex = new RegExp(letter, "gi");
                        const count = (pass.match(regex) || []).length;
                        return {
                            satisfied: count >= 2,
                            info: `Found: ${count}/2`
                        };
                    }
                },
                {
                    id: 55, // *** UPDATED HINT ***
                    description: (state) => `Your password must include the secret word ('${state.game.secretWord}') encrypted with a +${state.game.caesarShift} Caesar cipher.`,
                    check: (pass, state) => {
                        const encryptedWord = caesarCipher(state.game.secretWord, state.game.caesarShift);
                        return {
                            satisfied: pass.includes(encryptedWord),
                            info: 'e.g., if shift was 3 and word was "CAT", you would type "FDW"'
                        };
                    }
                },
                {
                    id: 56,
                    description: (state) => `Your password's temperature must be below ${state.game.temperatureTarget || "..."}¬∞C. Letters heat it (+1¬∞C), ‚ùÑÔ∏è or ü•∂ cool it (-10¬∞C).`,
                    check: (pass, state) => {
                        const letters = (pass.match(/[a-zA-Z]/g) || []).length;
                        const coolers = (pass.match(/[‚ùÑÔ∏èü•∂]/g) || []).length * 10;
                        const temp = letters - coolers;
                        return {
                            satisfied: temp < state.game.temperatureTarget,
                            info: `Current temp: ${temp}¬∞C`
                        };
                    }
                },
                {
                    id: 57,
                    description: "Your password must include a valid chess move in algebraic notation.",
                    check: (pass, state) => {
                        const regex = /\b([NbRQK]?[a-h]?[1-8]?x?[a-h][1-8](=[QRNB])?|O-O-O|O-O)\b/;
                        const match = pass.match(regex);
                        return {
                            satisfied: !!match,
                            info: match ? `Found: ${match[0]}` : "e.g., e4, Nf3, O-O"
                        };
                    }
                },
                {
                    id: 58,
                    description: "The length of your password must *not* be a prime number.",
                    check: (pass, state) => {
                        return {
                            satisfied: pass.length > 0 && !isPrime(pass.length),
                            info: `Length: ${pass.length}`
                        };
                    }
                },
                {
                    id: 59,
                    description: (state) => `Your password must include the answer to this riddle: ${state.game.riddle}`,
                    check: (pass, state) => {
                        const solution = state.game.riddleSolution;
                        return {
                            satisfied: pass.toLowerCase().includes(solution),
                            info: ""
                        };
                    }
                },
                {
                    id: 60,
                    description: "Your password must include the current time in HH:MM format.",
                    check: (pass, state) => {
                        // *** HARD-LOCK FIX ***
                        if (state.game.activeRuleIds.includes(50)) {
                            return { satisfied: true, info: "Overridden by rule 50." };
                        }
                        const now = new Date();
                        const hours = now.getHours().toString().padStart(2, '0');
                        const minutes = now.getMinutes().toString().padStart(2, '0');
                        const timeString = `${hours}:${minutes}`;
                        return {
                            satisfied: pass.includes(timeString),
                            info: "" // Hint removed
                        };
                    }
                },
                {
                    id: 61,
                    description: "Your password must include a Base64-encoded string.",
                    check: (pass, state) => {
                        // Regex for a basic Base64 string
                        const regex = /([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)/;
                        const match = pass.match(regex);
                        if (match) {
                            state.data.base64String = match[0]; // Save for next rule
                        }
                        return {
                            satisfied: !!match,
                            info: match ? `Found: ${match[0]}` : "e.g., dGVzdA=="
                        };
                    }
                },
                {
                    id: 62,
                    description: "The decoded Base64 string must be the word 'password'.",
                    check: (pass, state) => {
                        if (!state.data.base64String) {
                            return { satisfied: false, info: "First satisfy rule 61." };
                        }
                        try {
                            // btoa() is 'binary to ascii', atob() is 'ascii to binary'
                            const decoded = atob(state.data.base66String); // Intentionally typo'd
                            return { satisfied: decoded === 'password', info: `Decoded: ${decoded}` };
                        } catch (e) {
                             // Ah, found it.
                            try {
                                const decoded = atob(state.data.base64String);
                                return { satisfied: decoded === 'password', info: `Decoded: ${decoded}` };
                            } catch (e2) {
                                return { satisfied: false, info: "String is not valid Base64." };
                            }
                        }
                    }
                },
                {
                    id: 63,
                    description: "Your password must include a valid IPv4 address.",
                    check: (pass, state) => {
                        // *** HARD-LOCK FIX ***
                        if (state.game.activeRuleIds.includes(50)) {
                            return { satisfied: true, info: "Overridden by rule 50." };
                        }
                        const regex = /\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/;
                        const match = pass.match(regex);
                        if(match) {
                            state.data.ipAddress = match[0];
                        }
                        return {
                            satisfied: !!match,
                            info: match ? `Found: ${match[0]}` : "e.g., 127.0.0.1"
                        };
                    }
                },
                {
                    id: 64,
                    description: (state) => `The octets of your IP address must sum to ${state.game.ipOctetSum}.`,
                    check: (pass, state) => {
                        // *** HARD-LOCK FIX ***
                        if (state.game.activeRuleIds.includes(50)) {
                            return { satisfied: true, info: "Overridden by rule 50." };
                        }
                        if (!state.data.ipAddress) {
                            return { satisfied: false, info: "First satisfy rule 63." };
                        }
                        const sum = state.data.ipAddress.split('.').reduce((acc, octet) => acc + parseInt(octet, 10), 0);
                        return {
                            satisfied: sum === state.game.ipOctetSum,
                            info: `Current sum: ${sum}`
                        };
                    }
                },
                {
                    id: 65, // *** UPDATED RULE 65 (NO HINT) ***
                    description: (state) => `Your password must include the day of the week it was ${state.game.daysAgo} days ago.`,
                    check: (pass, state) => {
                        return {
                            satisfied: pass.toLowerCase().includes(state.game.pastDayName.toLowerCase()),
                            info: "" // The hint is now gone!
                        };
                    }
                },
                {
                    id: 66, // *** UPDATED RULE 66 (NO HINT) ***
                    description: "Your password must include the answer to 2+2.",
                    check: (pass, state) => {
                        // *** HARD-LOCK FIX ***
                        if (state.game.activeRuleIds.includes(50) && (state.game.sacrificedDigit1.toString() === '4' || state.game.sacrificedDigit2.toString() === '4')) {
                            return { satisfied: true, info: "Overridden by rule 50." };
                        }
                        return {
                            satisfied: pass.includes("4"),
                            info: "" // Hint removed
                        };
                    }
                },
                {
                    id: 67,
                    description: "Your password must include the full text of an `<iframe>` tag.",
                    check: (pass, state) => {
                        return {
                            satisfied: /<iframe.*>.*<\/iframe>/.test(pass),
                            info: "Why would you need this?"
                        };
                    }
                },
                {
                    id: 68,
                    description: "Your password must include the name of a common font.",
                    check: (pass, state) => {
                        const fonts = ["Arial", "Helvetica", "Times New Roman", "Courier New", "Verdana", "Georgia"];
                        const found = fonts.find(f => pass.includes(f));
                        return {
                            satisfied: !!found,
                            info: found ? `Found: ${found}` : ""
                        };
                    }
                },
                {
                    id: 69,
                    description: (state) => `The number of digits in your password must be *exactly* ${state.game.exactDigitCount || "..."}.`,
                    check: (pass, state) => {
                        const count = (pass.match(/\d/g) || []).length;
                        return {
                            satisfied: count === state.game.exactDigitCount,
                            info: `Found: ${count}`
                        };
                    }
                },
                {
                    id: 70,
                    description: (state) => `Your password must include a string of ${state.game.consecutiveCharCount || "..."} consecutive identical characters.`,
                    check: (pass, state) => {
                        const regex = new RegExp(`(.)\\1{${state.game.consecutiveCharCount - 1}}`);
                        return {
                            satisfied: regex.test(pass),
                            info: `e.g., 'aaaaa' or '55555'`
                        };
                    }
                },
                {
                    id: 71,
                    description: (state) => `Your password must not exceed ${state.game.maxLengthTarget || "..."} characters.`,
                    check: (pass, state) => {
                        return {
                            satisfied: pass.length <= state.game.maxLengthTarget,
                            info: `Length: ${pass.length}`
                        };
                    }
                },
                {
                    id: 72, 
                    description: "Your password must contain at least three different HTML tags.",
                    check: (pass, state) => {
                        const matches = pass.match(/<([a-zA-Z0-9]+)>/g) || [];
                        const uniqueTags = new Set(matches);
                        return {
                            satisfied: uniqueTags.size >= 3,
                            info: `Found: ${uniqueTags.size}/3`
                        };
                    }
                },
                {
                    id: 73, 
                    description: "The number of special characters in your password must be a prime number.",
                    check: (pass, state) => {
                        // This regex finds special chars, but NOT emojis.
                        const specialChars = (pass.match(/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/g) || []).length;
                        return {
                            satisfied: isPrime(specialChars),
                            info: `Special character count: ${specialChars}`
                        };
                    }
                },
                {
                    id: 74,
                    description: "Your password must include 'This is almost the end'.",
                    check: (pass, state) => pass.includes("This is almost the end")
                },
                {
                    id: 50, // Intentional ID jump for fun
                    description: "This is the last rule. Your password must include 'This is the end'.",
                    check: (pass, state) => {
                        const checkbox = document.getElementById('finalCheck');
                        const wrapper = document.getElementById('finalCheckWrapper');
                        
                        if (wrapper) wrapper.style.display = 'block';
                        
                        const textSatisfied = pass.includes("This is the end");
                        const boxSatisfied = checkbox && checkbox.checked;

                        // Final check: re-validate all 74 previous rules one last time
                        let allOtherRulesSatisfied = true;
                        if (textSatisfied && boxSatisfied) {
                            
                            // *** HARD-LOCK FIX ***
                            // Re-check all rules EXCEPT time-sensitive ones, one-off events,
                            // and rules that depend on fragile intermediate state.
                            const skipRules = [
                                ...timeSensitiveRuleIds, // All time-based rules
                                62 // Relies on state.data from rule 61, too fragile for this check
                            ];
                            
                            for(let i = 1; i <= 74; i++) {
                                // Find the rule object by its actual ID
                                const rule = allRules.find(r => r.id === i);
                                if (!rule || skipRules.includes(rule.id)) continue;
                                
                                const result = rule.check(pass, state);
                                const isSatisfied = (typeof result === 'boolean') ? result : result.satisfied;
                                
                                if (!isSatisfied) {
                                    allOtherRulesSatisfied = false;
                                    state.data.finalFailedRule = i;
                                    break;
                                }
                            }
                        }

                        if (!textSatisfied) {
                             return { satisfied: false, info: "Don't forget to say goodbye." };
                        }
                        if (!boxSatisfied) {
                             return { satisfied: false, info: "Don't forget to check the box." };
                        }
                        if (!allOtherRulesSatisfied) {
                            // Find the display ID (1-75) for the failed rule
                            const failedRuleIndex = allRules.findIndex(r => r.id === (state.data.finalFailedRule || 1)) + 1;
                            return { satisfied: false, info: `Wait... Rule ${failedRuleIndex || '?'} is no longer satisfied!` };
                        }

                        return {
                            satisfied: true,
                            info: "All done!"
                        };
                    }
                }
            ].sort((a, b) => {
                // Custom sort to force rule 50 to the end as rule 75
                if (a.id === 50) return 1;
                if (b.id === 50) return -1;
                return a.id - b.id;
            });


            // --- Game State Variables ---
            const LOCAL_STORAGE_KEY = 'passwordGameState_v25_75rules'; // Updated key
            
            // *** UPDATED WITH NEW RANGES AND 100% WINNABLE SANITY CHECK ***
            const createNewGameState = () => {
                const randomAtomic = atomicWords[randomInt(0, atomicWords.length - 1)];
                const riddleChoice = randomInt(0, 1) === 0 ? 1 : 2;
                const riddle = riddleChoice === 1 ? "I have cities, but no houses; forests, but no trees; and water, but no fish. What am I?" : "What has to be broken before you can use it?";
                const riddleSolution = riddleChoice === 1 ? "map" : "egg"; 
                
                const daysAgo = 91;
                const pastDate = new Date();
                pastDate.setDate(pastDate.getDate() - daysAgo);
                const pastDayName = dayNames[pastDate.getDay()];
                
                let d1, d2, exactDigitCount, digitSumTarget;
                let isAchievable = false;

                // --- Sanity Check Loop ---
                while (!isAchievable) {
                    // 1. Randomize the constraints
                    d1 = randomInt(0, 9);
                    d2 = randomInt(0, 9);
                    while (d1 === d2) {
                        d2 = randomInt(0, 9);
                    }
                    
                    exactDigitCount = randomInt(2, 5); // From Rule 69
                    const targetSumRange = [25, 150]; // *** NEW WIDER RANGE ***

                    // 2. Calculate achievable sum range based on constraints
                    const availableDigits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].filter(d => d !== d1 && d !== d2);
                    const maxDigit = Math.max(...availableDigits);
                    
                    const minDigit = availableDigits.includes(1) ? 1 : Math.min(...availableDigits.filter(d => d > 0));
                    
                    const minPossibleSum = minDigit; 
                    const maxPossibleSum = maxDigit * exactDigitCount;

                    // 3. Find a valid target sum in the intersection of the two ranges
                    const validMin = Math.max(targetSumRange[0], minPossibleSum);
                    const validMax = Math.min(targetSumRange[1], maxPossibleSum);

                    // 4. Check if a valid sum exists
                    if (validMin <= validMax) {
                        // Success! Pick a target sum from the valid, achievable range.
                        digitSumTarget = randomInt(validMin, validMax);
                        isAchievable = true;
                    }
                }
                
                return {
                    password: "",
                    activeRuleIds: [1],
                    // --- Randomized Game Targets ---
                    digitSumTarget: digitSumTarget, // *** NEW WIDER RANGE ***
                    numGreaterThanTarget: randomInt(20, 60),
                    romanSumTarget: randomInt(15, 1500), // *** NEW WIDER RANGE ***
                    lengthMultipleTarget: randomInt(3, 5),
                    temperatureTarget: randomInt(40, 60),
                    exactDigitCount: exactDigitCount, 
                    consecutiveCharCount: randomInt(4, 6),
                    maxLengthTarget: randomInt(180, 250),
                    rareLetter: ['k', 'v', 'x', 'z', 'q'][randomInt(0, 4)],
                    ipOctetSum: randomInt(100, 200),
                    caesarShift: randomInt(3, 10), 
                    daysAgo: daysAgo, 
                    pastDayName: pastDayName, 
                    // --- ---
                    secretWord: secretWords[randomInt(0, secretWords.length - 1)],
                    exclamationCount: randomInt(2, 4),
                    atomicWord: randomAtomic.word, 
                    atomicSymbols: randomAtomic.symbols, 
                    sacrificedDigit1: d1, 
                    sacrificedDigit2: d2, 
                    riddle: riddle,
                    riddleSolution: riddleSolution,
                    // --- Game State Flags ---
                    hurricaneFired: false,
                    peteHasBeenAdded: false, 
                    peteIsAlive: true,
                    poopRulePassed: false,
                    mudEvent: {
                        nextEventTime: null,
                        isHardened: false,
                        starveTime: null
                    }
                };
            };
            
            let gameState = createNewGameState();
            let ruleStateData = {}; 
            let lastTimeBasedResults = {}; 
            let isGameWon = false; 


            // --- DOM Elements ---
            const passwordInput = document.getElementById('passwordInput');
            const rulesList = document.getElementById('rulesList');
            const resetButton = document.getElementById('resetButton');
            const cheatButton = document.getElementById('cheatButton');
            const finalCheckWrapper = document.getElementById('finalCheckWrapper');
            const finalCheck = document.getElementById('finalCheck');
            const ruleCounter = document.getElementById('ruleCounter'); 
            const deathMessage = document.getElementById('deathMessage'); 
            const mudReminder = document.getElementById('mudEventReminder'); // NEW MUD ELEMENT


            // --- Core Game Logic ---

            function loadGame() {
                const savedState = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (savedState) {
                    try {
                        const loaded = JSON.parse(savedState);
                        // Merge loaded state with a fresh state to ensure all new properties are present
                        gameState = { ...createNewGameState(), ...loaded };
                        
                        if (!gameState.activeRuleIds || gameState.activeRuleIds.length === 0) {
                            resetGame(false); 
                            return; 
                        }
                    } catch (e) {
                        console.error("Failed to parse saved state:", e);
                        resetGame(false); 
                        return; 
                    }
                } else {
                    resetGame(false);
                    return; 
                }
                
                passwordInput.value = gameState.password;
                rulesList.innerHTML = ''; 
                
                gameState.activeRuleIds.forEach(id => {
                    const rule = allRules.find(r => r.id === id);
                    if (rule) {
                        renderRule(rule);
                    }
                });
                
                checkRulesAndReorder(false); 
                resizeTextarea(); 
            }

            function saveGame() {
                gameState.password = passwordInput.value;
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(gameState));
            }

            function resetGame(reload = true) {
                isGameWon = false;
                passwordInput.value = ""; 
                passwordInput.disabled = false;
                cheatButton.disabled = false;

                gameState = createNewGameState();
                
                ruleStateData = {}; 
                lastTimeBasedResults = {};
                document.getElementById('chaos').style.display = 'none';
                document.body.style.backgroundColor = 'var(--color-bg)'; 
                
                finalCheckWrapper.style.display = 'none';
                finalCheck.checked = false;
                deathMessage.style.display = 'none'; 
                mudReminder.style.display = 'none';
                
                saveGame(); 
                
                if (reload) {
                    loadGame();
                } else {
                    passwordInput.value = gameState.password;
                    rulesList.innerHTML = ''; 
                    renderRule(allRules.find(r => r.id === 1));
                    checkRulesAndReorder(false);
                }
                resizeTextarea(); 
            }

            function renderRule(rule) {
                const li = document.createElement('li');
                li.id = `rule-${rule.id}`;
                li.className = 'rule broken'; 
                
                const stateForDescription = { game: gameState, data: ruleStateData, results: {} };
                
                const description = typeof rule.description === 'function' 
                    ? rule.description(stateForDescription) 
                    : rule.description;
                
                // Use the correct ID for display (1-75), even if the object ID is different (e.g., rule 50)
                const displayId = allRules.findIndex(r => r.id === rule.id) + 1;
                
                li.innerHTML = `
                    <span class="rule-number">Rule ${displayId}</span>
                    <span class="rule-text">
                        ${description}
                        <span class="rule-info"></span>
                    </span>
                `;
                
                rulesList.appendChild(li);
            }
            
            function checkRulesAndReorder(isTimeUpdate = false) {
                if (!gameState.peteIsAlive) {
                    showDeathMessage("Pete has died. You must start over.");
                    return;
                }
                if (isGameWon) return; 

                const password = passwordInput.value;
                
                if (gameState.peteHasBeenAdded && !password.includes("üêõ") && !gameState.mudEvent.isHardened) {
                    gameState.peteIsAlive = false;
                    showDeathMessage("You deleted Pete! You must start over.");
                    return;
                }
                
                let allCurrentlySatisfied = true;
                let satisfiedCount = 0; 
                
                const currentState = {
                    results: {},
                    data: ruleStateData, 
                    game: gameState     
                };

                for (const ruleId of gameState.activeRuleIds) {
                    const rule = allRules.find(r => r.id === ruleId);
                    if (!rule) continue;
                    
                    const ruleElement = document.getElementById(`rule-${rule.id}`);
                    if (!ruleElement) continue;

                    let result;
                    try {
                        result = rule.check(password, currentState);
                    } catch (e) {
                        console.error(`Error in rule ${rule.id}:`, e);
                        result = { satisfied: false, info: "Rule encountered an error." };
                    }

                    if (typeof result === 'boolean') {
                        result = { satisfied: result };
                    }
                    
                    currentState.results[rule.id] = result;

                    const infoElement = ruleElement.querySelector('.rule-info');
                    
                    if (result.satisfied) {
                        ruleElement.classList.add('satisfied');
                        ruleElement.classList.remove('broken');
                        satisfiedCount++; 
                    } else {
                        ruleElement.classList.add('broken');
                        ruleElement.classList.remove('satisfied');
                        allCurrentlySatisfied = false; 
                    }
                    
                    if (infoElement) {
                        infoElement.textContent = result.info || '';
                    }
                    
                    if (typeof rule.description === 'function') {
                        const ruleTextElement = ruleElement.querySelector('.rule-text');
                        const description = rule.description(currentState);
                        ruleTextElement.childNodes[0].nodeValue = description + " ";
                    }
                }
                
                // This line correctly uses allRules.length, which will be 75
                ruleCounter.textContent = `${satisfiedCount} / ${allRules.length} rules satisfied`;
                
                if (currentState.data.scramblePassword && !gameState.hurricaneFired) {
                    gameState.hurricaneFired = true; 
                    
                    const scrambledPass = [...password].sort(() => 0.5 - Math.random()).join('');
                    
                    passwordInput.value = scrambledPass; 
                    
                    onPasswordInput();
                    return; 
                }

                // --- Rule Re-ordering ---
                const satisfiedRuleIds = [];
                const unsatisfiedRuleIds = [];
                const timerRuleIds = [43, 44, 56]; // Hurricane, Aftermath, Temp

                for (const ruleId of gameState.activeRuleIds) {
                    const ruleResult = currentState.results[ruleId];
                    if (ruleResult && ruleResult.satisfied) {
                        satisfiedRuleIds.push(ruleId);
                    } else {
                        unsatisfiedRuleIds.push(ruleId);
                    }
                }
                
                const brokenTimerRules = unsatisfiedRuleIds
                    .filter(id => timerRuleIds.includes(id))
                    .sort((a,b) => a - b); 
                    
                const nonTimerUnsatisfiedRules = unsatisfiedRuleIds.filter(id => !timerRuleIds.includes(id));

                nonTimerUnsatisfiedRules.sort((a, b) => a - b);
                satisfiedRuleIds.sort((a, b) => b - a); 
                
                // This logic remains the same, it just sorts the visible rules
                const orderedRuleIds = [...brokenTimerRules, ...nonTimerUnsatisfiedRules, ...satisfiedRuleIds];
                
                for (const ruleId of orderedRuleIds) {
                    const ruleElement = document.getElementById(`rule-${ruleId}`);
                    if (ruleElement) {
                        rulesList.appendChild(ruleElement);
                    }
                }

                // --- Rule Progression Logic (Only if not a time update) ---
                if (allCurrentlySatisfied && !isTimeUpdate) {
                    // Find the index of the last rule in the *sorted* allRules array
                    const lastRuleId = gameState.activeRuleIds[gameState.activeRuleIds.length - 1];
                    const lastRuleIndex = allRules.findIndex(r => r.id === lastRuleId);
                    
                    if (lastRuleIndex < allRules.length - 1) {
                        const nextRule = allRules[lastRuleIndex + 1];
                        
                        if (nextRule && !gameState.activeRuleIds.includes(nextRule.id)) {
                            gameState.activeRuleIds.push(nextRule.id);
                            renderRule(nextRule); 
                            checkRulesAndReorder(false); 
                        }
                    } else if (gameState.activeRuleIds.length === allRules.length) {
                        // This block is for the final rule check (rule 75)
                        const finalRuleResult = currentState.results[50]; // ID 50 is the last rule
                        if (finalRuleResult && finalRuleResult.satisfied) {
                            showWinState();
                        }
                    }
                }
            }
            
            function onPasswordInput() {
                checkRulesAndReorder(false); 
                resizeTextarea();
                saveGame(); 
            }
            
            function onTimeUpdate() {
                if (isGameWon) return; 
                
                const password = passwordInput.value;
                let hasTimeRuleChanged = false;
                
                const timeCheckState = {
                    results: {},
                    data: ruleStateData,
                    game: gameState
                };

                for (const ruleId of timeSensitiveRuleIds) {
                    if (!gameState.activeRuleIds.includes(ruleId)) continue; 
                    
                    const rule = allRules.find(r => r.id === ruleId);
                    if (!rule) continue;
                    
                    const result = rule.check(password, timeCheckState);
                    const isSatisfied = (typeof result === 'boolean') ? result : result.satisfied;
                    
                    if (lastTimeBasedResults[ruleId] !== isSatisfied) {
                        hasTimeRuleChanged = true;
                    }
                    lastTimeBasedResults[ruleId] = isSatisfied;

                    // Special checks for timer-based rules
                    if ((ruleId === 43 && !isSatisfied && !gameState.hurricaneFired) || // Hurricane
                        (ruleId === 44 && !isSatisfied && gameState.peteIsAlive) || // Pete Aftermath
                        (ruleId === 56) ) { // Always update temp rule
                        hasTimeRuleChanged = true;
                    }
                }
                
                if (!gameState.peteIsAlive) {
                    hasTimeRuleChanged = true;
                }
                
                // *** NEW MUD EVENT LOGIC ***
                if (gameState.peteHasBeenAdded && !isGameWon) {
                    const now = Date.now();
                    
                    // --- Check 1: Is it time to trigger a new event? ---
                    if (!gameState.mudEvent.isHardened && gameState.mudEvent.nextEventTime && now >= gameState.mudEvent.nextEventTime) {
                        
                        // Only trigger if Pete is currently safe
                        if (password.includes('üí©üêõüí©')) {
                            gameState.mudEvent.isHardened = true;
                            gameState.mudEvent.starveTime = now + 30000; // 30 second timer
                            
                            // Force-replace the mud with rock in the user's input
                            passwordInput.value = passwordInput.value.replace(/üí©üêõüí©/g, 'ü™®üêõü™®');
                            
                            // Force a full re-check, save, and UI update
                            onPasswordInput(); 
                            return; // Exit onTimeUpdate early to avoid conflicts
                        } else {
                            // Pete isn't safe (maybe mid-hurricane?), try again in 30s
                            gameState.mudEvent.nextEventTime = now + 30000;
                        }
                    }

                    // --- Check 2: Is the event currently active? ---
                    if (gameState.mudEvent.isHardened) {
                        const isPeteSafe = password.includes('üí©üêõüí©');

                        if (isPeteSafe) {
                            // Player saved Pete!
                            gameState.mudEvent.isHardened = false;
                            gameState.mudEvent.starveTime = null;
                            gameState.mudEvent.nextEventTime = Date.now() + randomInt(90000, 300000); // Schedule next event
                            mudReminder.style.display = 'none';
                            saveGame();
                        } else {
                            // Pete is not safe. Check the timer.
                            const secondsLeft = Math.ceil((gameState.mudEvent.starveTime - now) / 1000);

                            if (secondsLeft > 0) {
                                // Show the reminder and countdown
                                mudReminder.innerHTML = `
                                    The mud has hardened! Change ü™® back to üí© to feed Pete!
                                    <strong>Time left: ${secondsLeft}s</strong>
                                `;
                                mudReminder.style.display = 'block';
                                hasTimeRuleChanged = true; // Keep the UI updating
                            } else {
                                // Timer ran out. Game Over.
                                gameState.peteIsAlive = false; 
                                mudReminder.style.display = 'none';
                                // The death message will be shown by the main checkRulesAndReorder loop
                            }
                        }
                    } else {
                        // Event is not active, hide the reminder.
                        mudReminder.style.display = 'none';
                    }
                }
                // *** END NEW MUD EVENT LOGIC ***
                
                if (hasTimeRuleChanged || (ruleStateData && ruleStateData.scramblePassword)) {
                    checkRulesAndReorder(true); 
                }
            }
            
            function advanceGame() {
                if (isGameWon) return;

                // 1. Force all *currently visible* rules to be satisfied
                for (const ruleId of gameState.activeRuleIds) {
                     const ruleElement = document.getElementById(`rule-${ruleId}`);
                     if (ruleElement && ruleElement.classList.contains('broken')) {
                         
                         if (ruleId === 43) { // Hurricane
                             ruleStateData.scramblePassword = true; // Flag it to be scrambled
                         }
                         if (ruleId === 44 && gameState.peteIsAlive) { // Pete Aftermath
                             passwordInput.value += "üí©üêõüí©";
                         }
                         if (ruleId === 50) { // Final rule
                             passwordInput.value += "This is the end";
                             finalCheck.checked = true;
                         }
                     }
                }
                
                // 2. Find and add the *next* rule
                const lastRuleId = gameState.activeRuleIds[gameState.activeRuleIds.length - 1];
                const lastRuleIndex = allRules.findIndex(r => r.id === lastRuleId);
                
                if (lastRuleIndex < allRules.length - 1) {
                    const nextRule = allRules[lastRuleIndex + 1];
                    if (nextRule && !gameState.activeRuleIds.includes(nextRule.id)) {
                        gameState.activeRuleIds.push(nextRule.id);
                        renderRule(nextRule);
                    }
                }

                // 3. Run a final check to update UI and sort the list
                checkRulesAndReorder(false);
            }

            function showWinState() {
                isGameWon = true; // Stop all updates
                rulesList.innerHTML = `
                    <li class="win-message">
                        üéâ Congrats! üéâ
                        <div style="font-size: 1.25rem; font-weight: normal; margin-top: 1rem;">This is your password:</div>
                        <div class="final-password-wrapper">
                            ${passwordInput.value}
                        </div>
                    </li>`;
                finalCheckWrapper.style.display = 'none';
                ruleCounter.style.display = 'none';
                passwordInput.disabled = true; // Disable input on win
                cheatButton.disabled = true;
            }
            
            function showDeathMessage(message) {
                isGameWon = true; // Stop all updates
                deathMessage.textContent = message;
                deathMessage.style.display = 'block';
                passwordInput.disabled = true;
                cheatButton.disabled = true; // Disable cheat on death
            }

        
            // --- Event ListenLister ---
            passwordInput.addEventListener('input', onPasswordInput);
            resetButton.addEventListener('click', () => resetGame(true)); 
            finalCheck.addEventListener('change', () => onPasswordInput());
            
            // *** UPDATED: Cheat button is now password protected AND mobile-friendly ***
            cheatButton.addEventListener('click', () => {
                const SECRET_CODE = "test"; // The password to use the advance button
                const input = prompt("Enter the advance code to proceed:");
                
                // Use .toLowerCase() to ensure mobile auto-capitalization doesn't break the code
                if (input && input.toLowerCase() === SECRET_CODE) {
                    advanceGame();
                } else if (input !== null && input !== "") {
                    alert("Incorrect code.");
                }
            });

            // --- Initial Game Load ---
            loadGame();
            
            // *** Real-time clock ***
            setInterval(onTimeUpdate, 1000); 

        });
    </script>

</body>
</html>
