<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Impossible Password Game (Expressive-Only)</title>
    
    <style>
        /* --- M3 Expressive (WITH FLUID ANIMATIONS) --- */
        :root {
            /* M3 Expressive Color Palette */
            --color-bg: #FEF7FF;
            --color-text: #1E192B;
            --color-card: #FFFFFF;
            --color-input: #F3EDF7;
            --color-border: #CAC4D0;
            
            /* Primary (Purple) */
            --color-primary: #6750A4;
            --color-on-primary: #FFFFFF;
            --color-primary-container: #EADDFF;
            --color-on-primary-container: #21005E;

            /* Error (Red) */
            --color-error: #B3261E;
            --color-on-error: #FFFFFF;
            --color-error-container: #F9DEDC;
            --color-on-error-container: #410E0B;
            
            /* Neutral/Surface */
            --color-surface-variant: #E7E0EC;
            --color-on-surface-variant: #49454F;
            
            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-mono: "Courier New", Courier, monospace;
            
            /* --- Button Physics Shadows --- */
            --shadow-base: 0 4px 6px rgba(0,0,0,0.05);
            --shadow-hover: 0 6px 10px rgba(0,0,0,0.1);
            --shadow-active: 0 2px 4px rgba(0,0,0,0.05);
            
            --border-radius: 28px;
            --border-radius-small: 12px;

            /* --- M3 Easing Curves --- */
            --m3-ease-decelerate: cubic-bezier(0.0, 0.0, 0.2, 1.0);  /* For elements ENTERING */
            --m3-ease-standard: cubic-bezier(0.4, 0.0, 0.2, 1.0);    /* For standard fade/change */
            
            /* --- The "boing" (doioioing) spring --- */
            --m3-ease-physics-spring: cubic-bezier(0.3, 0.7, 0.3, 1.3); /* Overshoot 1.3, starts fast */
            
            /* --- Tuned Semantic Durations --- */
            --m3-duration-short: 200ms;       /* For small, quick feedback (hovers, focus) */
            --m3-duration-standard: 300ms;    /* For standard state changes (color fades) */
            --m3-duration-entrance: 400ms;    /* For new element entrances */
            --m3-duration-fluid-settle: 500ms;/* For the "boing" re-sort */
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--color-bg);
            color: var(--color-text);
            font-family: var(--font-main);
            line-height: 1.6;
            padding: 1rem;
        }
        
        /* --- NEW: Alert Overlay --- */
        #alertOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: var(--color-error); /* Use the error color */
            opacity: 0;
            pointer-events: none; /* Click through it */
            z-index: 100000;
            transition: opacity var(--m3-duration-short) var(--m3-ease-standard);
        }

        #alertOverlay.dimmed {
            opacity: 0.2; /* 20% dim */
        }
        
        @keyframes flash-red {
            0% { opacity: 0; }
            50% { opacity: 0.3; } /* Flash to 30% */
            100% { opacity: 0; }
        }

        #alertOverlay.flashing {
            animation: flash-red var(--m3-duration-standard) var(--m3-ease-decelerate);
        }


        /* --- Main Layout --- */
        .container {
            max-width: 700px;
            margin: 2rem auto;
            padding: 1.5rem;
            background-color: var(--color-card);
            border-radius: var(--border-radius);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            position: relative;
            border: 1px solid var(--color-border);
        }

        h1 {
            text-align: center;
            color: var(--color-primary);
            margin-top: 3.5rem; 
            margin-bottom: 0.5rem;
            font-size: 2rem;
            font-weight: 700;
        }

        h1 .icon {
            display: inline-block;
        }

        .intro {
            text-align: center;
            color: var(--color-on-surface-variant);
            margin-bottom: 2rem;
            font-style: italic;
        }

        /* --- Password Input & Highlighter --- */
        
        .password-wrapper {
            position: relative;
            margin-bottom: 1rem;
            background-color: var(--color-input);
            border: 2px solid var(--color-input);
            border-radius: var(--border-radius-small);
            transition: 
                background-color var(--m3-duration-short) var(--m3-ease-standard),
                border-color var(--m3-duration-short) var(--m3-ease-standard),
                outline var(--m3-duration-short) var(--m3-ease-standard);
        }
        
        .password-wrapper:has(#passwordInput:focus) {
            outline: 2px solid var(--color-primary);
            border-color: var(--color-primary);
            background-color: var(--color-bg);
        }

        #passwordInput, #highlighter {
            display: block;
            width: 100%;
            min-height: 60px;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            font-family: var(--font-mono);
            line-height: 1.6; 
            white-space: pre-wrap;
            word-break: break-all;
            
            border: none;
            outline: none;
            resize: none; 
            margin: 0;
        }

        #passwordInput {
            position: relative;
            z-index: 2;
            background-color: transparent !important;
            color: var(--color-text);
            caret-color: var(--color-text);
            overflow: hidden;
        }
        
        #passwordInput:disabled {
            background-color: #eee !important;
            color: #999;
        }

        #highlighter {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            overflow: hidden;
            color: transparent;
            pointer-events: none;
            user-select: none;
        }

        .highlight-error {
            background-color: var(--color-error-container);
            border-radius: 4px;
        }


        /* --- Rule Counter --- */
        #ruleCounter {
            font-weight: bold;
            color: var(--color-primary);
            text-align: center;
            margin-bottom: 1.5rem;
            font-size: 1.1rem;
        }

        /* --- Rules List --- */
        #rulesList {
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            position: relative; /* <-- ADDED for z-index context */
        }

        .rule {
            display: flex;
            align-items: center;
            padding: 0.75rem 1.25rem;
            border-radius: var(--border-radius);
            border: 2px solid var(--color-border);
            min-height: 52px;
            font-weight: 500;
            
            /* z-index will be managed by JS for animations */
            
            transition: 
                background-color var(--m3-duration-standard) var(--m3-ease-standard),
                border-color var(--m3-duration-standard) var(--m3-ease-standard),
                color var(--m3-duration-standard) var(--m3-ease-standard);
        }
        
        .rule-number {
            font-weight: 700;
            color: var(--color-on-surface-variant);
            margin-right: 0.75rem;
            font-size: 1.1rem;
            flex-shrink: 0;
        }

        .rule-text {
            flex-grow: 1;
            color: var(--color-on-surface-variant);
        }
        
        .rule .rule-number,
        .rule .rule-text,
        .rule .rule-info {
            transition: color var(--m3-duration-standard) var(--m3-ease-standard);
        }

        .rule-info {
            display: block;
            font-size: 0.9rem;
            font-style: italic;
            color: var(--color-on-surface-variant);
            margin-top: 0.25rem;
        }

        .rule.satisfied {
            background-color: var(--color-primary);
            border-color: var(--color-primary);
            color: var(--color-on-primary);
        }
        
        .rule.satisfied .rule-number,
        .rule.satisfied .rule-text,
        .rule.satisfied .rule-info {
            color: var(--color-on-primary);
        }
        
        .rule.broken {
            background-color: var(--color-error);
            border-color: var(--color-error);
            color: var(--color-on-error);
        }
        
        .rule.broken .rule-number,
        .rule.broken .rule-text,
        .rule.broken .rule-info {
            color: var(--color-on-error);
        }

        .rule.satisfied::before,
        .rule.broken::before {
            content: "";
            margin-right: 0;
        }
        
        .rule .emoji {
            text-shadow: 0 0 1px rgba(0,0,0,0.4);
        }
        .rule.satisfied .emoji,
        .rule.broken .emoji {
            text-shadow: 0 0 3px rgba(255,255,255,0.7), 
                         0 0 5px rgba(255,255,255,0.5);
        }

        /* --- MODIFIED: Rule Entrance Animation --- */
        @keyframes rule-enter {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.95); /* Slide from BOTTOM */
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .rule.entering {
            /* MODIFIED: Use physics spring for the "boing" */
            animation: rule-enter var(--m3-duration-entrance) var(--m3-ease-physics-spring);
        }
        
        /* --- Final Checkbox --- */
        #finalCheckWrapper {
            display: none; 
            margin-bottom: 1.5rem; 
            padding: 1rem;
            background-color: var(--color-primary-container);
            border-radius: var(--border-radius);
            text-align: center;
        }
        
        #finalCheckWrapper label {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--color-on-primary-container);
            cursor: pointer;
        }
        
        #finalCheck {
            margin-right: 0.75rem;
            transform: scale(1.5);
            accent-color: var(--color-primary);
            cursor: pointer;
        }
        
        /* --- NEW: Mud Event Reminder --- */
        #mudEventReminder {
            display: none;
            padding: 1rem;
            margin-bottom: 1rem;
            background-color: var(--color-error-container);
            border: 2px solid var(--color-error);
            border-radius: var(--border-radius);
            color: var(--color-on-error-container);
            font-size: 1.1rem;
            font-weight: 500;
            text-align: center;
            line-height: 1.5;
        }
        
        #mudEventReminder strong {
            color: var(--color-error);
            font-size: 1.2rem;
            display: block;
            margin-top: 0.5rem;
        }

        /* --- Button Controls --- */
        #resetButton, #cheatButton {
            position: absolute;
            top: 1.5rem;
            padding: 0.5rem 1.25rem;
            font-size: 0.9rem;
            font-weight: bold;
            border-radius: 28px;
            cursor: pointer;
            height: 40px;
            
            transform: scale(1);
            box-shadow: var(--shadow-base);
            transition: 
                transform var(--m3-duration-short) var(--m3-ease-standard),
                box-shadow var(--m3-duration-short) var(--m3-ease-standard);
        }

        #resetButton:hover, #cheatButton:hover {
            transform: scale(1.05);
            box-shadow: var(--shadow-hover);
        }
        
        #resetButton:active, #cheatButton:active {
            transform: scale(0.98);
            box-shadow: var(--shadow-active);
        }

        #resetButton {
            left: 1.5rem;
            background-color: var(--color-error-container);
            color: var(--color-on-error-container);
            border: 1px solid var(--color-error-container);
            position: absolute;
            overflow: hidden;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        #resetButton .fill {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--color-error);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.2s linear;
            z-index: 1;
        }
        
        #resetButton .text {
            position: relative;
            z-index: 2;
            transition: color 0.2s linear;
        }
        
        #resetButton.holding .fill {
            transform: scaleX(1);
            transition-duration: 2s;
            transition-timing-function: linear;
        }
        #resetButton.holding .text {
             color: var(--color-on-error);
             transition-duration: 0.2s;
        }
        
        
        #cheatButton {
            right: 1.5rem;
            background-color: var(--color-primary-container);
            border: 1px solid var(--color-primary-container);
            color: var(--color-on-primary-container);
        }
        #cheatButton:hover {
            background-color: var(--color-primary);
            color: var(--color-on-primary);
        }

        /* --- Win State --- */
        .win-message {
            text-align: center;
            font-size: 2rem;
            color: var(--color-primary);
        }
        
        .final-password-wrapper {
            font-size: 1.25rem;
            font-weight: normal;
            color: var(--color-text);
            background-color: var(--color-input);
            padding: 1rem;
            border-radius: var(--border-radius-small);
            border: 2px solid var(--color-border);
            margin-top: 1.5rem;
            word-break: break-all;
            font-family: var(--font-mono);
        }
        
        /* --- Death Message --- */
        @keyframes shake {
            0% { transform: translate(-50%, -50%) translateX(0); }
            20% { transform: translate(-50%, -50%) translateX(-10px); }
            40% { transform: translate(-50%, -50%) translateX(10px); }
            60% { transform: translate(-50%, -50%) translateX(-10px); }
            80% { transform: translate(-50%, -50%) translateX(10px); }
            100% { transform: translate(-50%, -50%) translateX(0); }
        }

        #deathMessage {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            opacity: 0;
            transition: 
                opacity var(--m3-duration-short) var(--m3-ease-standard),
                transform var(--m3-duration-short) var(--m3-ease-decelerate);
            
            padding: 2rem;
            background-color: var(--color-error-container);
            color: var(--color-error);
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            z-index: 10000;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-base);
            border: 2px solid var(--color-error);
        }
        
        #deathMessage.visible {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        #deathMessage.visible.shaking {
            animation: shake var(--m3-duration-standard) var(--m3-ease-decelerate);
        }

        /* --- Chaos Element --- */
        #chaos {
            position: fixed;
            font-size: 2rem;
            z-index: 9999;
            display: none; 
        }

        /* --- Responsive Design --- */
        @media (max-width: 600px) {
            body { padding: 0.5rem; }
            .container { margin: 0.5rem auto; padding: 1rem; }
            h1 { font-size: 1.5rem; margin-top: 4rem; }
            #passwordInput { font-size: 1rem; padding: 0.75rem 1rem; min-height: 50px; }
            .rule { padding: 0.75rem 1rem; }
            .rule-number { font-size: 1rem; margin-right: 0.5rem; }
            #resetButton, #cheatButton { padding: 0.25rem 0.75rem; font-size: 0.8rem; top: 1rem; }
            #resetButton { left: 1rem; }
            #cheatButton { right: 1rem; }
        }
    </style>
</head>
<body>

    <!-- NEW: Alert Overlay -->
    <div id="alertOverlay"></div>

    <div id="chaos"></div>
    
    <div id="deathMessage"></div>

    <main class="container">
        
        <button id="resetButton">
            <span class="fill"></span>
            <span class="text">Start Over</span>
        </button>
        <button id="cheatButton">Advance (Test)</button>

        <h1><span class="icon">ðŸ”’</span> The Impossible Password Game</h1>
        <p class="intro">How hard can it be? ...Right?</p>

        <div class="password-wrapper">
            <div id="highlighter" aria-hidden="true"></div>
            <textarea id="passwordInput" placeholder="Enter password..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" rows="1"></textarea>
        </div>

        <div id="ruleCounter">0 / 75 rules satisfied</div>
        
        <div id="finalCheckWrapper">
            <label>
                <input type="checkbox" id="finalCheck">
                I've read all the rules and this is the end.
            </label>
        </div>
        
        <div id="mudEventReminder"></div>

        <ol id="rulesList"></ol>
        
    </main>

    <script>
        /**************************************************************************
         * *
         * WELCOME TO THE PASSWORD GAME JAVASCRIPT                 *
         * *
         **************************************************************************/

        document.addEventListener('DOMContentLoaded', () => {

            // --- Helper Functions ---
            
            const isPrime = (num) => {
                if (num <= 1) return false;
                if (num <= 3) return true;
                if (num % 2 === 0 || num % 3 === 0) return false;
                for (let i = 5; i * i <= num; i = i + 6) {
                    if (num % i === 0 || num % (i + 2) === 0) return false;
                }
                return true;
            };
            
            const getZodiacSign = (date) => {
                const day = date.getDate();
                const month = date.getMonth() + 1;
                const signs = ["Capricorn", "Aquarius", "Pisces", "Aries", "Taurus", "Gemini", "Cancer", "Leo", "Virgo", "Libra", "Scorpio", "Sagittarius", "Capricorn"];
                const endDates = [19, 18, 20, 19, 20, 20, 22, 22, 22, 22, 21, 21, 19];
                return (day > endDates[month - 1]) ? signs[month] : signs[month - 1];
            };

            const reverseString = (str) => str.split("").reverse().join("");

            const totalSumAllDigits = (pass) => {
                 return (pass.match(/\d/g) || []).reduce((acc, digit) => acc + parseInt(digit, 10), 0);
            }
            
            // Helper to escape regex special characters
            function escapeRegExp(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            // --- NEW: YouTube URL Validation ---
            const GEMINI_API_KEY = "AIzaSyCdhhnq3twazYVLzvHWQ1Ab5czjLUPo5-I";
            // Stricter regex to capture the 11-character ID
            const YOUTUBE_URL_REGEX = /(https?:\/\/)?(www\.)?(youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11})/;

            /**
             * Uses Gemini with Search grounding to check if a YouTube URL is real.
             * @param {string} videoUrl - The full URL to check.
             * @param {string} videoId - The 11-character video ID.
             * @param {object} state - The ruleStateData object to update.
             */
            async function checkYoutubeUrl(videoUrl, videoId, state) {
                if (!GEMINI_API_KEY) {
                    console.error("Gemini API key is missing.");
                    state.youtubeCheckStatus = 'invalid'; // Fail if no key
                    return;
                }

                state.isYoutubeCheckRunning = true;
                state.youtubeCheckUrl = videoUrl;
                state.youtubeCheckStatus = 'checking';

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${GEMINI_API_KEY}`;
                
                const systemPrompt = "You are a silent fact-checking assistant. The user will provide a YouTube URL. You must use your search tool to determine if this URL links to a real, public, and existing video. Respond with ONLY 'YES' if the video is real and public, and 'NO' if it is fake, private, deleted, or does not exist. Do not add any other words or punctuation.";
                const userQuery = videoUrl;

                const payload = {
                    contents: [{ parts: [{ text: userQuery }] }],
                    tools: [{ "google_search": {} }],
                    systemInstruction: {
                        parts: [{ text: systemPrompt }]
                    },
                };

                try {
                    // Implement exponential backoff for retries
                    let response;
                    let retries = 0;
                    const maxRetries = 3;
                    let delay = 1000;

                    while (retries < maxRetries) {
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            break; // Success
                        }

                        if (response.status === 429 || response.status >= 500) {
                            // Throttled or server error, wait and retry
                            retries++;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2; // Exponential backoff
                        } else {
                            // Other client-side error (e.g., 400), don't retry
                            throw new Error(`API request failed with status ${response.status}`);
                        }
                    }

                    if (!response || !response.ok) {
                        throw new Error(`API request failed after ${maxRetries} retries.`);
                    }

                    const result = await response.json();
                    const candidate = result.candidates?.[0];
                    const text = candidate?.content?.parts?.[0]?.text?.trim().toUpperCase();
                    
                    if (text === 'YES') {
                        state.youtubeCheckStatus = 'valid';
                        // Try to get a title from grounding metadata for a better UI
                        const attribution = candidate.groundingMetadata?.groundingAttributions?.[0];
                        state.youtubeVideoTitle = attribution?.web?.title || videoId;
                    } else {
                        state.youtubeCheckStatus = 'invalid';
                    }

                } catch (error) {
                    console.error("Error checking YouTube URL:", error);
                    state.youtubeCheckStatus = 'invalid'; // Set as invalid on error
                } finally {
                    state.isYoutubeCheckRunning = false;
                }
            }
            // --- END: YouTube URL Validation ---


            const findElement = (str) => {
                const elements = {
                    "hydrogen": { "symbol": "H" }, "helium": { "symbol": "He" }, "lithium": { "symbol": "Li" }, "beryllium": { "symbol": "Be" }, "boron": { "symbol": "B" }, "carbon": { "symbol": "C" }, "nitrogen": { "symbol": "N" }, "oxygen": { "symbol": "O" }, "fluorine": { "symbol": "F" }, "neon": { "symbol": "Ne" }, "sodium": { "symbol": "Na" }, "magnesium": { "symbol": "Mg" }, "aluminium": { "symbol": "Al" }, "aluminum": { "symbol": "Al" }, "silicon": { "symbol": "Si" }, "phosphorus": { "symbol": "P" }, "sulfur": { "symbol": "S" }, "chlorine": { "symbol": "Cl" }, "argon": { "symbol": "Ar" }, "potassium": { "symbol": "K" }, "calcium": { "symbol": "Ca" }, "scandium": { "symbol": "Sc" }, "titanium": { "symbol": "Ti" }, "vanadium": { "symbol": "V" }, "chromium": { "symbol": "Cr" }, "manganese": { "symbol": "Mn" }, "iron": { "symbol": "Fe" }, "cobalt": { "symbol": "Co" }, "nickel": { "symbol": "Ni" }, "copper": { "symbol": "Cu" }, "zinc": { "symbol": "Zn" }, "gallium": { "symbol": "Ga" }, "germanium": { "symbol": "Ge" }, "arsenic": { "symbol": "As" }, "selenium": { "symbol": "Se" }, "bromine": { "symbol": "Br" }, "krypton": { "symbol": "Kr" }, "rubidium": { "symbol": "Rb" }, "strontium": { "symbol": "Sr" }, "yttrium": { "symbol": "Y" }, "zirconium": { "symbol": "Zr" }, "niobium": { "symbol": "Nb" }, "molybdenum": { "symbol": "Mo" }, "technetium": { "symbol": "Tc" }, "ruthenium": { "symbol": "Ru" }, "rhodium": { "symbol": "Rh" }, "palladium": { "symbol": "Pd" }, "silver": { "symbol": "Ag" }, "cadmium": { "symbol":"Cd" }, "indium": { "symbol": "In" }, "tin": { "symbol": "Sn" }, "antimony": { "symbol": "Sb" }, "tellurium": { "symbol": "Te" }, "iodine": { "symbol": "I" }, "xenon": { "symbol": "Xe" }, "caesium": { "symbol": "Cs" }, "cesium": { "symbol": "Cs" }, "barium": { "symbol": "Ba" }, "lanthanum": { "symbol": "La" }, "cerium": { "symbol": "Ce" }, "praseodymium": { "symbol": "Pr" }, "neodymium": { "symbol":"Nd" }, "promethium": { "symbol": "Pm" }, "samarium": { "symbol": "Sm" }, "europium": { "symbol": "Eu" }, "gadolinium": { "symbol": "Gd" }, "terbium": { "symbol": "Tb" }, "dysprosium": { "symbol": "Dy" }, "holmium": { "symbol": "Ho" }, "erbium": { "symbol": "Er" }, "thulium": { "symbol": "Tm" }, "ytterbium": { "symbol": "Yb" }, "lutetium": { "symbol": "Lu" }, "hafnium": { "symbol": "Hf" }, "tantalum": { "symbol": "Ta" }, "tungsten": { "symbol": "W" }, "rhenium": { "symbol": "Re" }, "osmium": { "symbol": "Os" }, "iridium": { "symbol": "Ir" }, "platinum": { "symbol": "Pt" }, "gold": { "symbol": "Au" }, "mercury": { "symbol": "Hg" }, "thallium": { "symbol": "Tl" }, "lead": { "symbol": "Pb" }, "bismuth": { "symbol": "Bi" }, "polonium": { "symbol": "Po" }, "astatine": { "symbol": "At" }, "radon": { "symbol": "Rn" }, "francium": { "symbol": "Fr" }, "radium": { "symbol": "Ra" }, "actinium": { "symbol": "Ac" }, "thorium": { "symbol": "Th" }, "protactinium": { "symbol": "Pa" }, "uranium": { "symbol": "U" }, "neptunium": { "symbol": "Np" }, "plutonium": { "symbol": "Pu" }, "americium": { "symbol": "Am" }, "curium": { "symbol": "Cm" }, "berkelium": { "symbol": "Bk" }, "californium": { "symbol": "Cf" }, "einsteinium": { "symbol": "Es" }, "fermium": { "symbol": "Fm" }, "mendelevium": { "symbol": "Md" }, "nobelium": { "symbol": "No" }, "lawrencium": { "symbol": "Lr" }, "rutherfordium": { "symbol": "Rf" }, "dubnium": { "symbol": "Db" }, "seaborgium": { "symbol": "Sg" }, "bohrium": { "symbol": "Bh" }, "hassium": { "symbol": "Hs" }, "meitnerium": { "symbol": "Mt" }, "darmstadtium": { "symbol": "Ds" }, "roentgenium": { "symbol": "Rg" }, "copernicium": { "symbol": "Cn" }, "nihonium": { "symbol": "Nh" }, "flerovium": { "symbol": "Fl" }, "moscovium": { "symbol": "Mc" }, "livermorium": { "symbol": "Lv" }, "tennessine": { "symbol": "Ts" }, "oganesson": { "symbol": "Og" }
                };
                
                const lowerPass = str.toLowerCase();
                for (const name in elements) {
                    if (lowerPass.includes(name)) {
                        return { name, symbol: elements[name].symbol };
                    }
                }
                return null;
            };

            const toRoman = (num) => {
                if (num < 1 || num > 3999) return ""; 
                const roman = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };
                let str = '';
                for (let i in roman) {
                    while (num >= roman[i]) {
                        str += i;
                        num -= roman[i];
                    }
                }
                return str;
            };
            
            const parseRoman = (str) => {
                const values = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 };
                let total = 0;
                for (let i = 0; i < str.length; i++) {
                    const current = values[str[i]];
                    const next = values[str[i + 1]];
                    
                    if (next && current < next) {
                        total -= current;
                    } else {
                        total += current;
                    }
                }
                return total;
            };

            const caesarCipher = (str, shift) => {
                return str.split('').map(char => {
                    const code = char.charCodeAt(0);
                    // Uppercase letters
                    if (code >= 65 && code <= 90) {
                        return String.fromCharCode(((code - 65 + shift) % 26) + 65);
                    }
                    // Lowercase letters
                    if (code >= 97 && code <= 122) {
                        return String.fromCharCode(((code - 97 + shift) % 26) + 97);
                    }
                    // Not a letter, return as is
                    return char;
                }).join('');
            };
            
            const resizeTextarea = () => {
                passwordInput.style.height = 'auto'; 
                passwordInput.style.height = (passwordInput.scrollHeight + 2) + 'px';
                syncScroll();
            }
            
            function syncScroll() {
                if (!highlighter) return;
                highlighter.scrollTop = passwordInput.scrollTop;
                highlighter.scrollLeft = passwordInput.scrollLeft;
                highlighter.style.height = passwordInput.style.height;
            }

            function updateHighlighter(pass, highlightRegexes) {
                if (!highlighter) return;

                let combinedRegex = null;
                if (highlightRegexes.length > 0) {
                    const patterns = highlightRegexes.map(r => `(${r.source})`);
                    combinedRegex = new RegExp(patterns.join('|'), 'g');
                }

                let escapedPass = pass
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                
                if (combinedRegex) {
                    escapedPass = escapedPass.replace(combinedRegex, (match) => {
                        return `<span class="highlight-error">${match}</span>`;
                    });
                }
                
                highlighter.innerHTML = escapedPass + '&#8203;'; 
                
                syncScroll();
            }

            // --- NEW: Visual Alert Function ---
            function triggerVisualAlert(type = 'flash') {
                if (!alertOverlay) return;

                if (type === 'flash') {
                    alertOverlay.classList.remove('dimmed');
                    alertOverlay.classList.add('flashing');
                    alertOverlay.addEventListener('animationend', () => {
                        alertOverlay.classList.remove('flashing');
                    }, { once: true });
                } else if (type === 'dim') {
                    alertOverlay.classList.remove('flashing');
                    alertOverlay.classList.add('dimmed');
                } else if (type === 'clear') {
                    alertOverlay.classList.remove('dimmed');
                    alertOverlay.classList.remove('flashing');
                }
            }


            // --- Randomized Rule Data ---
            const secretWords = ["QRABO", "SKEEN", "ZUPPO", "FLORK", "BRYNG", "AOWKS", "EQWPS", "PYTOR", "ZAJEY", "KREEP", "WOTOK", "FYOOG", "SPOK", "GREEB", "THRAW", "YOOOP", "BAZER", "JOPPA", "GRONK", "PWYBO"];
            const carMakers = ["Abarth", "Acura", "Alfa Romeo", "Alpine", "Aston Martin", "Audi", "Bentley", "BMW", "Bugatti", "Buick", "Cadillac", "Chevrolet", "Chrysler", "CitroÃ«n", "Dacia", "Dodge", "Ferrari", "Fiat", "Ford", "Genesis", "GMC", "Honda", "Hyundai", "Infiniti", "Jaguar", "Jeep", "Kia", "Koenigsegg", "Lamborghini", "Land Rover", "Lexus", "Lincoln", "Lotus", "Maserati", "Mazda", "McLaren", "Mercedes-Benz", "Mini", "Mitsubishi", "Nissan", "Opel", "Peugeot", "Porsche", "Ram", "Renault", "Rolls-Royce", "Subaru", "Suzuki", "Tesla", "Toyota", "Vauxhall", "Volkswagen", "Volvo"];
            const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
            
            const atomicWords = [
                { "word": "SNOW", "symbols": ["S", "N", "O", "W"] },
                { "word": "BOSS", "symbols": ["B", "O", "S", "S"] },
                { "word": "GeNiUS", "symbols": ["Ge", "Ni", "U", "S"] },
                { "word": "SAtUrN", "symbols": ["S", "At", "U", "Rn"] },
                { "word": "KNiFe", "symbols": ["K", "Ni", "Fe"] },
                { "word": "CaFe", "symbols": ["Ca", "Fe"] }
            ];

            const allCountryCodes = ["AF","AX","AL","DZ","AS","AD","AO","AI","AQ","AG","AR","AM","AW","AU","AT","AZ","BS","BH","BD","BB","BY","BE","BZ","BJ","BM","BT","BO","BQ","BA","BW","BV","BR","IO","BN","BG","BF","BI","CV","KH","CM","CA","KY","CF","TD","CL","CN","CX","CC","CO","KM","CG","CD","CK","CR","CI","HR","CU","CW","CY","CZ","DK","DJ","DM","DO","EC","EG","SV","GQ","ER","EE","SZ","ET","FK","FO","FJ","FI","FR","GF","PF","TF","GA","GM","GE","DE","GH","GI","GR","GL","GD","GP","GU","GT","GG","GN","GW","GY","HT","HM","VA","HN","HK","HU","IS","IN","ID","IR","IQ","IE","IM","IL","IT","JM","JP","JE","JO","KZ","KE","KI","KP","KR","KW","KG","LA","LV","LB","LS","LR","LY","LI","LT","LU","MO","MG","MW","MY","MV","ML","MT","MH","MQ","MR","MU","YT","MX","FM","MD","MC","MN","ME","MS","MA","MZ","MM","NA","NR","NP","NL","NC","NZ","NI","NE","NG","NU","NF","MP","NO","OM","PK","PW","PS","PA","PG","PY","PE","PH","PN","PL","PT","PR","QA","MK","RO","RU","RW","RE","BL","SH","KN","LC","MF","PM","VC","WS","SM","ST","SA","SN","RS","SC","SL","SG","SX","SK","SI","SB","SO","ZA","GS","SS","ES","LK","SD","SR","SJ","SE","CH","SY","TW","TJ","TZ","TH","TL","TG","TK","TO","TT","TN","TR","TM","TC","TV","UG","UA","AE","GB","US","UM","UY","UZ","VU","VE","VN","VG","VI","WF","EH","YE","ZM","ZW"];
            
            const usStateCodes = ["AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA", "HI", "ID", "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", "NM", "NY", "NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT", "VT", "VA", "WA", "WV", "WI", "WY"];
            
            const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

            // --- List of Time-Sensitive Rule IDs ---
            const timeSensitiveRuleIds = [12, 21, 35, 36, 43, 44, 52, 56, 60];


            // --- ALL 75 RULES ARE DEFINED HERE ---

            const allRules = [
                {
                    id: 1,
                    description: "Your password must be at least 5 characters long.",
                    check: (pass, state) => pass.length >= 5
                },
                {
                    id: 2,
                    description: "Your password must include a number.",
                    check: (pass, state) => /\d/.test(pass)
                },
                {
                    id: 3,
                    description: "Your password must include an uppercase letter.",
                    check: (pass, state) => /[A-Z]/.test(pass)
                },
                {
                    id: 4,
                    description: "Your password must include a special character.",
                    check: (pass, state) => /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(pass)
                },
                {
                    id: 5,
                    description: "Your password must include the word 'password'.",
                    check: (pass, state) => {
                        const isSatisfied = pass.toLowerCase().includes("password");
                        return {
                            satisfied: isSatisfied,
                            highlightRegex: isSatisfied ? null : /password/gi
                        };
                    }
                },
                {
                    id: 6,
                    description: (state) => `Your password must include a number greater than ${state.game.numGreaterThanTarget || "..."}.`,
                    check: (pass, state) => {
                        const matches = pass.match(/\d+/g) || [];
                        const isSatisfied = matches.some(num => parseInt(num, 10) > state.game.numGreaterThanTarget);
                        
                        const failingNumbers = matches
                            .filter(numStr => parseInt(numStr, 10) <= state.game.numGreaterThanTarget)
                            .map(escapeRegExp);
                            
                        return {
                            satisfied: isSatisfied,
                            highlightRegex: (isSatisfied || failingNumbers.length === 0) ? null : new RegExp(failingNumbers.join('|'), 'g')
                        };
                    }
                },
                {
                    id: 7,
                    description: "Your password must include an emoji.",
                    check: (pass, state) => {
                        const regex = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/;
                        return regex.test(pass);
                    }
                },
                {
                    id: 8,
                    description: "A cow says... Your password must include 'moo'.",
                    check: (pass, state) => {
                        const isSatisfied = pass.toLowerCase().includes("moo");
                        return {
                            satisfied: isSatisfied,
                            highlightRegex: isSatisfied ? null : /moo/gi
                        };
                    }
                },
                {
                    id: 9,
                    description: "Your password must include a common punctuation mark.",
                    check: (pass, state) => {
                         return {
                            satisfied: /[.,?!]/.test(pass),
                            info: "e.g., . , ? !"
                         };
                    }
                },
                {
                    id: 10,
                    description: "Your password must be at least 10 characters long.",
                    check: (pass, state) => pass.length >= 10
                },
                {
                    id: 11,
                    description: "Your password must include a color name.",
                    check: (pass, state) => {
                        const colors = ["red", "blue", "green", "yellow", "orange", "purple", "black", "white", "pink", "brown", "cyan", "magenta", "lime", "teal", "navy", "olive", "maroon", "silver", "gold", "aqua", "beige", "indigo", "violet"];
                        return colors.some(c => pass.toLowerCase().includes(c));
                    }
                },
                {
                    id: 12,
                    description: "Your password must include the current day of the week.",
                    check: (pass, state) => {
                        const day = dayNames[new Date().getDay()];
                        const isSatisfied = pass.toLowerCase().includes(day.toLowerCase());
                        return {
                            satisfied: isSatisfied,
                            info: "",
                            highlightRegex: isSatisfied ? null : new RegExp(day, "gi")
                        };
                    }
                },
                {
                    id: 13,
                    description: "Your password must *not* include the letter 'e'.",
                    check: (pass, state) => {
                         if (state.game.activeRuleIds.includes(12) || state.game.activeRuleIds.includes(37) || state.game.activeRuleIds.includes(74) || state.game.activeRuleIds.includes(50)) {
                             return { satisfied: true, info: "Rule overridden by a later rule." };
                         }
                         const isSatisfied = !pass.toLowerCase().includes('e');
                         return {
                            satisfied: isSatisfied,
                            info: "The most common letter! Good luck.",
                            highlightRegex: isSatisfied ? null : /e/gi
                         };
                    }
                },
                {
                    id: 14,
                    description: "Your password must include an uppercase Roman numeral.",
                    check: (pass, state) => {
                        const match = pass.match(/[IVXLCDM]/); 
                        return {
                            satisfied: !!match,
                            info: match ? `Found: ${match[0]}` : ""
                        };
                    }
                },
                {
                    id: 15,
                    description: (state) => `The uppercase Roman numerals in your password must sum to ${state.game.romanSumTarget || "..."}.`,
                    check: (pass, state) => {
                        const matches = pass.match(/[IVXLCDM]+/g) || [];
                        const sum = matches.reduce((acc, str) => acc + parseRoman(str), 0);
                        const isSatisfied = sum === state.game.romanSumTarget;
                        return {
                            satisfied: isSatisfied,
                            info: `Current Roman sum: ${sum}`,
                            highlightRegex: isSatisfied ? null : /[IVXLCDM]/gi 
                        };
                    }
                },
                {
                    id: 16,
                    description: (state) => `The digits in your password must add up to ${state.game.digitSumTarget || "..."}.`,
                    check: (pass, state) => {
                        if (state.game.activeRuleIds.includes(50)) {
                            return { satisfied: true, info: "Overridden by rule 50." };
                        }
                        if (state.game.activeRuleIds.includes(34)) {
                             return { satisfied: true, info: "Overridden by rule 34." };
                        }
                        const totalSum = totalSumAllDigits(pass);
                        const isSatisfied = totalSum === state.game.digitSumTarget;
                        return {
                            satisfied: isSatisfied,
                            info: `Current sum: ${totalSum}`,
                            highlightRegex: isSatisfied ? null : /\d/g
                        };
                    }
                },
                {
                    id: 17,
                    description: "Your password must include a 4-letter word.",
                    check: (pass, state) => {
                        return {
                            satisfied: /\b[a-zA-Z]{4}\b/.test(pass),
                            info: "e.g., 'this' or 'word'"
                        };
                    }
                },
                {
                    id: 18,
                    description: "Your password must include a valid hex color code.",
                    check: (pass, state) => {
                        const match = pass.match(/#[0-9a-fA-F]{6}/);
                        return {
                            satisfied: !!match,
                            info: match ? `Found: ${match[0]}` : ""
                        };
                    }
                },
                {
                    id: 19,
                    description: "Your hex color must be a shade of green.",
                    check: (pass, state) => {
                        const match = pass.match(/#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})/);
                        if (!match) {
                            return { satisfied: false, info: "First satisfy rule 18." };
                        }
                        const r = parseInt(match[1], 16);
                        const g = parseInt(match[2], 16);
                        const b = parseInt(match[3], 16);
                        const isSatisfied = g > r && g > b && g > 100;
                        return {
                            satisfied: isSatisfied,
                            info: `Found: rgb(${r}, ${g}, ${b})`,
                            highlightRegex: isSatisfied ? null : /#[0-9a-fA-F]{6}/g
                        };
                    }
                },
                {
                    id: 20,
                    description: (state) => `Your password must include this game's secret word: ${state.game.secretWord || "..."}`,
                    check: (pass, state) => {
                        const isSatisfied = pass.includes(state.game.secretWord);
                        return {
                            satisfied: isSatisfied,
                            highlightRegex: isSatisfied ? null : new RegExp(escapeRegExp(state.game.secretWord), "g")
                        };
                    }
                },
                {
                    id: 21,
                    description: "Your password must include the current month.",
                    check: (pass, state, isTimeUpdate) => {
                        const month = monthNames[new Date().getMonth()];
                        const isSatisfied = pass.toLowerCase().includes(month.toLowerCase());
                        return {
                            satisfied: isSatisfied,
                            info: "",
                            highlightRegex: isSatisfied ? null : new RegExp(month, "gi")
                        };
                    }
                },
                {
                    id: 22,
                    description: "Your password must include a 2-letter US state abbreviation.",
                    check: (pass, state) => {
                        const found = usStateCodes.find(code => pass.includes(code));
                        return {
                            satisfied: !!found,
                            info: found ? `Found: ${found}` : ""
                        };
                    }
                },
                {
                    id: 23,
                    description: "Your password must include 'password', but spelled backwards.",
                    check: (pass, state) => {
                        const isSatisfied = pass.includes("drowssap");
                        return {
                            satisfied: isSatisfied,
                            highlightRegex: isSatisfied ? null : /drowssap/gi
                        };
                    }
                },
                {
                    id: 24,
                    description: "Your password must include a zodiac sign.",
                    check: (pass, state) => {
                        const signs = ["aries", "taurus", "gemini", "cancer", "leo", "virgo", "libra", "scorpio", "sagittarius", "capricorn", "aquarius", "pisces"];
                        const found = signs.find(sign => pass.toLowerCase().includes(sign));
                        return {
                            satisfied: !!found,
                            info: ""
                        };
                    }
                },
                {
                    id: 25,
                    description: "The length of your password must be a prime number.",
                    check: (pass, state) => {
                        if (state.game.activeRuleIds.includes(58)) {
                            return { satisfied: true, info: "Overridden by rule 58." };
                        }
                        return {
                            satisfied: isPrime(pass.length),
                            info: `Length: ${pass.length}`
                        };
                    }
                },
                {
                    id: 26,
                    description: "Your password must include a car manufacturer.",
                    check: (pass, state) => {
                        const found = carMakers.find(c => pass.toLowerCase().includes(c.toLowerCase()));
                        return {
                            satisfied: !!found,
                            info: found ? `Found: ${found}` : ""
                        };
                    }
                },
                {
                    id: 27,
                    description: "Your password must include two poop emojis: <span class='emoji'>ðŸ’©</span><span class='emoji'>ðŸ’©</span>.",
                    check: (pass, state) => {
                        if (state.game.poopRulePassed) {
                            return { satisfied: true, info: "Requirement met." };
                        }
                        
                        const count = (pass.match(/ðŸ’©/g) || []).length;
                        if (count >= 2) {
                            state.game.poopRulePassed = true;
                            saveGame();
                            return { satisfied: true, info: "Requirement met." };
                        }
                        return {
                            satisfied: false,
                            info: `Found: ${count}`
                        };
                    }
                },
                {
                    id: 28,
                    description: "Oh no! A wild <span class='emoji'>ðŸ›</span> has appeared... His name is Pete. Keep him safe in some soil <span class='emoji'>ðŸ’©</span><span class='emoji'>ðŸ›</span><span class='emoji'>ðŸ’©</span>.",
                    check: (pass, state) => {
                        const chaosEl = document.getElementById('chaos');
                        const isSafe = pass.includes("ðŸ’©ðŸ›ðŸ’©");

                        if (!state.data.peteSpawned) {
                            state.data.peteSpawned = true;
                            chaosEl.textContent = "ðŸ›";
                            chaosEl.style.top = `${randomInt(10, 80)}vh`;
                            chaosEl.style.left = `${randomInt(5, 20)}vw`;
                            if (Math.random() > 0.5) {
                                chaosEl.style.left = `${randomInt(75, 90)}vw`;
                            }
                            chaosEl.style.display = "block";
                        }
                        
                        if (isSafe) {
                            chaosEl.style.display = "none";
                            
                            if (!state.game.peteHasBeenAdded) {
                                state.game.peteHasBeenAdded = true;
                                state.game.mudEvent.nextEventTime = Date.now() + randomInt(90000, 300000);
                                saveGame(); 
                            }
                        } else {
                            if (!state.game.peteHasBeenAdded) {
                                chaosEl.style.display = "block";
                            }
                        }
                        
                        if (!state.game.peteHasBeenAdded) {
                             return {
                                satisfied: isSafe,
                                highlightRegex: isSafe ? null : /ðŸ›/g // Highlight the lonely caterpillar
                            };
                        }
                        
                        return { satisfied: true, info: "Pete is in your password." };
                    }
                },
                {
                    id: 29,
                    description: "Your password must contain a 'sponsored' segment.",
                    check: (pass, state) => {
                        const isSatisfied = pass.toLowerCase().includes("sponsored by");
                        return {
                            satisfied: isSatisfied,
                            highlightRegex: isSatisfied ? null : /sponsored by/gi
                        };
                    }
                },
                {
                    id: 30,
                    description: "Your password must include a continent.",
                    check: (pass, state) => {
                        const continents = ["africa", "antarctica", "asia", "australia", "europe", "north america", "south america"];
                        const found = continents.find(c => pass.toLowerCase().includes(c));
                        return {
                            satisfied: !!found,
                            info: ""
                        };
                    }
                },
                {
                    id: 31,
                    description: "Your password must include an element from the periodic table.",
                    check: (pass, state) => {
                        const element = findElement(pass);
                        state.data.element = element;
                        return {
                            satisfied: !!element,
                            info: element ? `Found: ${element.name}` : ""
                        };
                    }
                },
                {
                    id: 32,
                    description: "Your password must include the atomic *symbol* of that element.",
                    check: (pass, state) => {
                        const element = state.data.element; 
                        if (!element) {
                            return { satisfied: false, info: "First satisfy rule 31." };
                        }
                        const isSatisfied = pass.includes(element.symbol);
                        return {
                            satisfied: isSatisfied,
                            info: `Element: ${element.name}`,
                            highlightRegex: isSatisfied ? null : new RegExp(escapeRegExp(element.symbol), "g")
                        };
                    }
                },
                {
                    id: 33,
                    description: "Your password must include a true math equation.",
                    check: (pass, state) => {
                        const match = pass.match(/(\d+)\s*([+\-*/])\s*(\d+)\s*=\s*(\d+)/);
                        if (!match) {
                            return { satisfied: false, info: "e.g., 2+2=4" };
                        }
                        const n1 = parseFloat(match[1]);
                        const op = match[2];
                        const n2 = parseFloat(match[3]);
                        const n3 = parseFloat(match[4]);
                        
                        let result;
                        if (op === '+') result = n1 + n2;
                        else if (op === '-') result = n1 - n2;
                        else if (op === '*') result = n1 * n2;
                        else if (op === '/') result = n1 / n2;
                        
                        const isSatisfied = result === n3;
                        return {
                            satisfied: isSatisfied,
                            info: isSatisfied ? `Found: ${match[0]}` : `${match[0]} is false.`,
                            highlightRegex: isSatisfied ? null : new RegExp(escapeRegExp(match[0]), 'g')
                        };
                    }
                },
                {
                    id: 34,
                    description: "The sum of all digits in your password must be odd.",
                    check: (pass, state) => {
                        const totalSum = totalSumAllDigits(pass);
                        const isSatisfied = totalSum > 0 && totalSum % 2 !== 0;
                        return {
                            satisfied: isSatisfied,
                            info: `Current sum: ${totalSum}`,
                            highlightRegex: isSatisfied ? null : /\d/g
                        };
                    }
                },
                {
                    id: 35,
                    description: "Your password must include the current hour (24-hour format).",
                    check: (pass, state, isTimeUpdate) => {
                        if (state.game.activeRuleIds.includes(37)) {
                            return { satisfied: true, info: "Overridden by rule 37." };
                        }
                        if (state.game.activeRuleIds.includes(50)) {
                            return { satisfied: true, info: "Overridden by rule 50." };
                        }
                        const hour = new Date().getHours().toString();
                        const isSatisfied = pass.includes(hour);
                        return {
                            satisfied: isSatisfied,
                            info: "",
                            highlightRegex: isSatisfied ? null : new RegExp(hour, "g")
                        };
                    }
                },
                {
                    id: 36,
                    description: "Your password must include the current minute.",
                    check: (pass, state, isTimeUpdate) => {
                        if (state.game.activeRuleIds.includes(37)) {
                            return { satisfied: true, info: "Overridden by rule 37." };
                        }
                        if (state.game.activeRuleIds.includes(50)) {
                            return { satisfied: true, info: "Overridden by rule 50." };
                        }
                        const minute = new Date().getMinutes().toString();
                        const isSatisfied = pass.includes(minute);
                        return {
                            satisfied: isSatisfied,
                            info: "",
                            highlightRegex: isSatisfied ? null : new RegExp(minute, "g")
                        };
                    }
                },
                {
                    id: 37,
                    description: "That was mean. Just include 'time'.",
                    check: (pass, state) => {
                        const isSatisfied = pass.toLowerCase().includes("time");
                        return {
                            satisfied: isSatisfied,
                            highlightRegex: isSatisfied ? null : /time/gi
                        };
                    }
                },
                {
                    id: 38,
                    description: (state) => `Your password must include the chemical symbols in this word: **${state.game.atomicWord}**`,
                    check: (pass, state) => {
                        const symbols = state.game.atomicSymbols;
                        const satisfied = symbols.every(symbol => pass.includes(symbol));
                        return {
                            satisfied: satisfied,
                            info: "e.g., 'CaFe' requires 'Ca' and 'Fe'",
                            highlightRegex: satisfied ? null : new RegExp(symbols.map(escapeRegExp).join('|'), "g")
                        };
                    }
                },
                {
                    id: 39,
                    description: "Your password must include a valid, public YouTube video URL.",
                    check: (pass, state) => {
                        const match = pass.match(YOUTUBE_URL_REGEX);
                        
                        if (!match) {
                            // Reset state if URL is removed
                            if (state.data.youtubeCheckStatus === 'valid') {
                                state.data.youtubeCheckStatus = null;
                                state.data.youtubeCheckUrl = null;
                                state.data.youtubeVideoTitle = null;
                            }
                            return { satisfied: false, info: "e.g., youtube.com/watch?v=..." };
                        }
                        
                        const videoUrl = match[0];
                        const videoId = match[3]; // The 11-character ID

                        // Trigger check if URL is new and not already running
                        if (videoUrl !== state.data.youtubeCheckUrl && !state.data.isYoutubeCheckRunning) {
                            // Pass the state.data object to be modified
                            checkYoutubeUrl(videoUrl, videoId, state.data);
                        }

                        // Return status based on saved state
                        switch (state.data.youtubeCheckStatus) {
                            case 'valid':
                                // Use the video title if we found one, otherwise just the URL
                                const infoText = state.data.youtubeVideoTitle ? `Found: ${state.data.youtubeVideoTitle}` : "Video Found";
                                return { satisfied: true, info: infoText };
                            case 'invalid':
                                return { satisfied: false, info: "Video not found or is private.", highlightRegex: new RegExp(escapeRegExp(videoUrl), 'g') };
                            case 'checking':
                                return { satisfied: false, info: "Checking URL..." };
                            default:
                                // This case happens when the regex matches but the check hasn't started
                                return { satisfied: false, info: "Validating URL..." };
                        }
                    }
                },
                {
                    id: 40,
                    description: (state) => `Your password must contain exactly ${state.game.exclamationCount || "..."} exclamation marks.`,
                    check: (pass, state) => {
                        const count = (pass.match(/!/g) || []).length;
                        const isSatisfied = count === state.game.exclamationCount;
                        return {
                            satisfied: isSatisfied,
                            info: `Found: ${count}`,
                            highlightRegex: isSatisfied ? null : /!/g
                        };
                    }
                },
                {
                    id: 41,
                    description: "Your password must include a two-letter country code.",
                    check: (pass, state) => {
                        const found = allCountryCodes.find(code => pass.includes(code));
                        return {
                            satisfied: !!found,
                            info: found ? `Found: ${found}` : ""
                        };
                    }
                },
                {
                    id: 42,
                    description: `Your password must contain the Konami code (letters only).`,
                    check: (pass, state) => {
                        const isSatisfied = pass.toLowerCase().includes("uuddlrlrba");
                        return {
                            satisfied: isSatisfied,
                            info: "e.g., up=u up=u ... b=b a=a",
                            highlightRegex: isSatisfied ? null : /uuddlrlrba/gi
                        };
                    }
                },
                {
                    id: 43,
                    description: "ðŸŒªï¸ A hurricane is coming! Quick, copy your password!",
                    check: (pass, state, isTimeUpdate) => {
                        if (state.game.hurricaneFired) {
                            return { satisfied: true, info: "The hurricane has passed." };
                        }
                        if (!state.data.hurricaneTimerStarted) {
                            state.data.hurricaneTimerStarted = Date.now();
                        }
                        
                        let secondsLeft = 5;
                        // Only check time if this is a time-based update
                        if(isTimeUpdate) {
                            const elapsed = Date.now() - state.data.hurricaneTimerStarted;
                            secondsLeft = 5 - Math.floor(elapsed / 1000);
                            state.data.lastHurricaneTime = Date.now(); // Store last check time
                        } else {
                            // On a regular check, just show the last known time
                            const elapsed = (state.data.lastHurricaneTime || Date.now()) - state.data.hurricaneTimerStarted;
                            secondsLeft = 5 - Math.floor(elapsed / 1000);
                        }
                        
                        if (secondsLeft > 0 && secondsLeft <= 3) {
                            if(isTimeUpdate) triggerVisualAlert('flash');
                            return { satisfied: false, info: `Scrambling in ${secondsLeft}s...` };
                        }
                        if (secondsLeft > 0) {
                            return { satisfied: false, info: `Scrambling in ${secondsLeft}s...` };
                        }
                        
                        state.data.scramblePassword = true;
                        return { satisfied: false, info: "BOOM!" };
                    }
                },
                {
                    id: 44,
                    description: "The hurricane passed! But Pete is exposed! Get him back in his soil <span class='emoji'>ðŸ’©</span><span class='emoji'>ðŸ›</span><span class='emoji'>ðŸ’©</span>.",
                    check: (pass, state, isTimeUpdate) => {
                        if (!state.game.peteIsAlive) {
                            return { satisfied: false, info: "It's too late for Pete." };
                        }
                        
                        if (pass.includes("ðŸ’©ðŸ›ðŸ’©")) {
                             state.data.peteTimerStarted = null;
                             if(isTimeUpdate) triggerVisualAlert('clear');
                             return { satisfied: true, info: "Phew, that was close." };
                        }
                        
                        if (!state.data.peteTimerStarted) {
                            state.data.peteTimerStarted = Date.now();
                        }

                        let secondsLeft = 10;
                        if(isTimeUpdate) {
                            const elapsed = Date.now() - state.data.peteTimerStarted;
                            secondsLeft = 10 - Math.floor(elapsed / 1000);
                            state.data.lastPeteTime = Date.now(); // Store last check time
                        } else {
                            const elapsed = (state.data.lastPeteTime || Date.now()) - state.data.peteTimerStarted;
                            secondsLeft = 10 - Math.floor(elapsed / 1000);
                        }


                        if (secondsLeft > 0) {
                            if(isTimeUpdate) triggerVisualAlert('dim');
                            return { satisfied: false, info: `Protect Pete! ${secondsLeft}s left...` };
                        }
                        
                        if(isTimeUpdate) triggerVisualAlert('clear');
                        gameState.peteIsAlive = false;
                        return { satisfied: false, info: "You were too slow... Pete is gone." };
                    }
                },
                {
                    id: 45,
                    description: "The number of uppercase letters must match the number of lowercase letters.",
                    check: (pass, state) => {
                        const upper = (pass.match(/[A-Z]/g) || []).length;
                        const lower = (pass.match(/[a-z]/g) || []).length;
                        const isSatisfied = upper > 0 && upper === lower;
                        return {
                            satisfied: isSatisfied,
                            info: `Upper: ${upper}, Lower: ${lower}`,
                            highlightRegex: isSatisfied ? null : /[a-zA-Z]/g
                        };
                    }
                },
                {
                    id: 46,
                    description: "Your password must include a word at least 8 letters long.",
                    check: (pass, state) => {
                        const longWords = pass.match(/\b[a-zA-Z]{8,}\b/g) || [];
                        const found = longWords.length > 0;
                        return {
                            satisfied: !!found,
                            info: found ? `Found: ${longWords[0]}` : null,
                            highlightRegex: found ? null : /[a-zA-Z]/g
                        };
                    }
                },
                {
                    id: 47,
                    description: "Your password must contain a major music triad.",
                    check: (pass, state) => {
                        const triads = ["C, E, G", "G, B, D", "F, A, C"];
                        const found = triads.find(t => pass.includes(t));
                        return {
                            satisfied: !!found,
                            info: found ? `Found: ${found}` : "e.g., C, E, G"
                        };
                    }
                },
                {
                    id: 48,
                    description: "Your password must include an HTML tag (e.g., &lt;p&gt;).",
                    check: (pass, state) => {
                        const match = pass.match(/<[a-zA-Z0-9]+>/);
                        return {
                            satisfied: !!match,
                            info: match ? `Found: ${match[0]}` : ""
                        };
                    }
                },
                {
                    id: 49,
                    description: "Your password must include the `<body>` HTML tag.",
                    check: (pass, state) => {
                        const isSatisfied = pass.includes("<body>");
                         return {
                            satisfied: isSatisfied,
                            info: "",
                            highlightRegex: isSatisfied ? null : /<body>/g
                        };
                    }
                },
                {
                    id: 50,
                    description: (state) => `You must sacrifice two digits. The digits **${state.game.sacrificedDigit1}** and **${state.game.sacrificedDigit2}** may not appear.`,
                    check: (pass, state) => {
                        const d1 = state.game.sacrificedDigit1.toString();
                        const d2 = state.game.sacrificedDigit2.toString();
                        const isSatisfied = !pass.includes(d1) && !pass.includes(d2);
                        return {
                            satisfied: isSatisfied,
                            info: `They will not be missed.`,
                            highlightRegex: isSatisfied ? null : new RegExp(`[${d1}${d2}]`, 'g')
                        };
                    }
                },
                {
                    id: 51,
                    description: "All instances of 's' or 'S' must be replaced with '$'.",
                    check: (pass, state) => {
                        const isSatisfied = !pass.toLowerCase().includes('s');
                        return {
                            satisfied: isSatisfied,
                            info: "A '$' is much cooler.",
                            highlightRegex: isSatisfied ? null : /s/gi
                        };
                    }
                },
                {
                    id: 52,
                    description: "Your password must include the current year.",
                    check: (pass, state, isTimeUpdate) => {
                        if (state.game.activeRuleIds.includes(50)) {
                            return { satisfied: true, info: "Overridden by rule 50." };
                        }
                        const year = new Date().getFullYear().toString();
                        const isSatisfied = pass.includes(year);
                        return {
                            satisfied: isSatisfied,
                            info: "",
                            highlightRegex: isSatisfied ? null : new RegExp(year, "g")
                        };
                    }
                },
                {
                    id: 53,
                    description: (state) => `Your password's length must be a multiple of ${state.game.lengthMultipleTarget || "..."}.`,
                    check: (pass, state) => {
                        return {
                            satisfied: pass.length > 0 && pass.length % state.game.lengthMultipleTarget === 0,
                            info: `Length: ${pass.length}`
                        };
                    }
                },
                {
                    id: 54,
                    description: (state) => `Your password must contain the letter **${state.game.rareLetter}** at least twice.`,
                    check: (pass, state) => {
                        const letter = state.game.rareLetter;
                        const regex = new RegExp(letter, "gi");
                        const count = (pass.match(regex) || []).length;
                        const isSatisfied = count >= 2;
                        return {
                            satisfied: isSatisfied,
                            info: `Found: ${count}/2`,
                            highlightRegex: isSatisfied ? null : new RegExp(letter, "gi")
                        };
                    }
                },
                {
                    id: 55,
                    description: (state) => `Your password must include the secret word ('${state.game.secretWord}') encrypted with a +${state.game.caesarShift} Caesar cipher.`,
                    check: (pass, state) => {
                        const encryptedWord = caesarCipher(state.game.secretWord, state.game.caesarShift);
                        const isSatisfied = pass.includes(encryptedWord);
                        return {
                            satisfied: isSatisfied,
                            info: 'e.g., if shift was 3 and word was "CAT", you would type "FDW"',
                            highlightRegex: isSatisfied ? null : new RegExp(escapeRegExp(encryptedWord), "g")
                        };
                    }
                },
                {
                    id: 56,
                    description: (state) => `Your password's temperature must be below ${state.game.temperatureTarget || "..."}Â°C. Letters heat it (+1Â°C), <span class='emoji'>â„ï¸</span> or <span class='emoji'>ðŸ¥¶</span> cool it (-10Â°C).`,
                    check: (pass, state) => {
                        const letters = (pass.match(/[a-zA-Z]/g) || []).length;
                        const coolers = (pass.match(/[â„ï¸ðŸ¥¶]/g) || []).length * 10;
                        const temp = letters - coolers;
                        const isSatisfied = temp < state.game.temperatureTarget;
                        return {
                            satisfied: isSatisfied,
                            info: `Current temp: ${temp}Â°C`,
                            highlightRegex: isSatisfied ? null : /[a-zA-Zâ„ï¸ðŸ¥¶]/g
                        };
                    }
                },
                {
                    id: 57,
                    description: "Your password must include a valid chess move in algebraic notation.",
                    check: (pass, state) => {
                        const regex = /\b([NbRQK]?[a-h]?[1-8]?x?[a-h][1-8](=[QRNB])?|O-O-O|O-O)\b/;
                        const match = pass.match(regex);
                        return {
                            satisfied: !!match,
                            info: match ? `Found: ${match[0]}` : "e.g., e4, Nf3, O-O"
                        };
                    }
                },
                {
                    id: 58,
                    description: "The length of your password must *not* be a prime number.",
                    check: (pass, state) => {
                        return {
                            satisfied: pass.length > 0 && !isPrime(pass.length),
                            info: `Length: ${pass.length}`
                        };
                    }
                },
                {
                    id: 59,
                    description: (state) => `Your password must include the answer to this riddle: ${state.game.riddle}`,
                    check: (pass, state) => {
                        const solution = state.game.riddleSolution;
                        const isSatisfied = pass.toLowerCase().includes(solution);
                        return {
                            satisfied: isSatisfied,
                            info: "",
                            highlightRegex: isSatisfied ? null : new RegExp(solution, "gi")
                        };
                    }
                },
                {
                    id: 60,
                    description: "Your password must include the current time in HH:MM format.",
                    check: (pass, state, isTimeUpdate) => {
                        if (state.game.activeRuleIds.includes(50)) {
                            return { satisfied: true, info: "Overridden by rule 50." };
                        }
                        const now = new Date();
                        const hours = now.getHours().toString().padStart(2, '0');
                        const minutes = now.getMinutes().toString().padStart(2, '0');
                        const timeString = `${hours}:${minutes}`;
                        const isSatisfied = pass.includes(timeString);
                        return {
                            satisfied: isSatisfied,
                            info: "",
                            highlightRegex: isSatisfied ? null : new RegExp(timeString, "g")
                        };
                    }
                },
                {
                    id: 61,
                    description: "Your password must include a Base64-encoded string.",
                    check: (pass, state) => {
                        const regex = /([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)/;
                        const match = pass.match(regex);
                        if (match) {
                            state.data.base64String = match[0];
                        }
                        return {
                            satisfied: !!match,
                            info: match ? `Found: ${match[0]}` : "e.g., dGVzdA=="
                        };
                    }
                },
                {
                    id: 62,
                    description: "The decoded Base64 string must be the word 'password'.",
                    check: (pass, state) => {
                        if (!state.data.base64String) {
                            return { satisfied: false, info: "First satisfy rule 61." };
                        }
                        let isSatisfied = false;
                        let decoded = "";
                        try {
                            decoded = atob(state.data.base64String);
                            isSatisfied = decoded === 'password';
                        } catch (e) {
                            // Invalid Base64
                        }
                        return { 
                            satisfied: isSatisfied, 
                            info: `Decoded: ${decoded || '???'}`,
                            highlightRegex: isSatisfied ? null : new RegExp(escapeRegExp(state.data.base64String), 'g')
                        };
                    }
                },
                {
                    id: 63,
                    description: "Your password must include a valid IPv4 address.",
                    check: (pass, state) => {
                        if (state.game.activeRuleIds.includes(50)) {
                            return { satisfied: true, info: "Overridden by rule 50." };
                        }
                        const regex = /\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/;
                        const match = pass.match(regex);
                        if(match) {
                            state.data.ipAddress = match[0];
                        }
                        return {
                            satisfied: !!match,
                            info: match ? `Found: ${match[0]}` : "e.g., 127.0.0.1"
                        };
                    }
                },
                {
                    id: 64,
                    description: (state) => `The octets of your IP address must sum to ${state.game.ipOctetSum}.`,
                    check: (pass, state) => {
                        if (state.game.activeRuleIds.includes(50)) {
                            return { satisfied: true, info: "Overridden by rule 50." };
                        }
                        if (!state.data.ipAddress || !pass.includes(state.data.ipAddress)) {
                            return { satisfied: false, info: "First satisfy rule 63." };
                        }
                        const sum = state.data.ipAddress.split('.').reduce((acc, octet) => acc + parseInt(octet, 10), 0);
                        const isSatisfied = sum === state.game.ipOctetSum;
                        return {
                            satisfied: isSatisfied,
                            info: `Current sum: ${sum}`,
                            highlightRegex: isSatisfied ? null : new RegExp(escapeRegExp(state.data.ipAddress), 'g')
                        };
                    }
                },
                {
                    id: 65,
                    description: (state) => `Your password must include the day of the week it was ${state.game.daysAgo} days ago.`,
                    check: (pass, state) => {
                        const isSatisfied = pass.toLowerCase().includes(state.game.pastDayName.toLowerCase());
                        return {
                            satisfied: isSatisfied,
                            info: "",
                            highlightRegex: isSatisfied ? null : new RegExp(state.game.pastDayName, "gi")
                        };
                    }
                },
                {
                    id: 66,
                    description: "Your password must include the answer to 2+2.",
                    check: (pass, state) => {
                        if (state.game.activeRuleIds.includes(50) && (state.game.sacrificedDigit1.toString() === '4' || state.game.sacrificedDigit2.toString() === '4')) {
                            return { satisfied: true, info: "Overridden by rule 50." };
                        }
                        const isSatisfied = pass.includes("4");
                        return {
                            satisfied: isSatisfied,
                            info: "",
                            highlightRegex: isSatisfied ? null : /4/g
                        };
                    }
                },
                {
                    id: 67,
                    description: "Your password must include the full text of an `<iframe>` tag.",
                    check: (pass, state) => {
                        return {
                            satisfied: /<iframe.*>.*<\/iframe>/.test(pass),
                            info: "Why would you need this?"
                        };
                    }
                },
                {
                    id: 68,
                    description: "Your password must include the name of a common font.",
                    check: (pass, state) => {
                        const fonts = ["Arial", "Helvetica", "Times New Roman", "Courier New", "Verdana", "Georgia"];
                        const found = fonts.find(f => pass.includes(f));
                        return {
                            satisfied: !!found,
                            info: found ? `Found: ${found}` : ""
                        };
                    }
                },
                {
                    id: 69,
                    description: (state) => `The number of digits in your password must be *exactly* ${state.game.exactDigitCount || "..."}.`,
                    check: (pass, state) => {
                        const count = (pass.match(/\d/g) || []).length;
                        const isSatisfied = count === state.game.exactDigitCount;
                        return {
                            satisfied: isSatisfied,
                            info: `Found: ${count}`,
                            highlightRegex: isSatisfied ? null : /\d/g
                        };
                    }
                },
                {
                    id: 70,
                    description: (state) => `Your password must include a string of ${state.game.consecutiveCharCount || "..."} consecutive identical characters.`,
                    check: (pass, state) => {
                        const regex = new RegExp(`(.)\\1{${state.game.consecutiveCharCount - 1}}`);
                        return {
                            satisfied: regex.test(pass),
                            info: `e.g., 'aaaaa' or '55555'`
                        };
                    }
                },
                {
                    id: 71,
                    description: (state) => `Your password must not exceed ${state.game.maxLengthTarget || "..."} characters.`,
                    check: (pass, state) => {
                        return {
                            satisfied: pass.length <= state.game.maxLengthTarget,
                            info: `Length: ${pass.length}`
                        };
                    }
                },
                {
                    id: 72, 
                    description: "Your password must contain at least three different HTML tags.",
                    check: (pass, state) => {
                        const matches = pass.match(/<([a-zA-Z0-9]+)>/g) || [];
                        const uniqueTags = new Set(matches);
                        return {
                            satisfied: uniqueTags.size >= 3,
                            info: `Found: ${uniqueTags.size}/3`
                        };
                    }
                },
                {
                    id: 73, 
                    description: "The number of special characters in your password must be a prime number.",
                    check: (pass, state) => {
                        const specialChars = (pass.match(/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/g) || []).length;
                        const isSatisfied = isPrime(specialChars);
                        return {
                            satisfied: isSatisfied,
                            info: `Special character count: ${specialChars}`,
                            highlightRegex: isSatisfied ? null : /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/g
                        };
                    }
                },
                {
                    id: 74,
                    description: "Your password must include 'This is almost the end'.",
                    check: (pass, state) => {
                        const isSatisfied = pass.includes("This is almost the end");
                        return {
                            satisfied: isSatisfied,
                            highlightRegex: isSatisfied ? null : /This is almost the end/g
                        };
                    }
                },
                {
                    id: 50, // Intentional ID jump for fun
                    description: "This is the last rule. Your password must include 'This is the end'.",
                    check: (pass, state) => {
                        const checkbox = document.getElementById('finalCheck');
                        const wrapper = document.getElementById('finalCheckWrapper');
                        
                        if (wrapper) wrapper.style.display = 'block';
                        
                        const textSatisfied = pass.includes("This is the end");
                        const boxSatisfied = checkbox && checkbox.checked;

                        let allOtherRulesSatisfied = true;
                        if (textSatisfied && boxSatisfied) {
                            
                            const skipRules = [
                                ...timeSensitiveRuleIds,
                                62
                            ];
                            
                            for(let i = 1; i <= 74; i++) {
                                const rule = allRules.find(r => r.id === i);
                                if (!rule || skipRules.includes(rule.id)) continue;
                                
                                const result = rule.check(pass, state);
                                const isSatisfied = (typeof result === 'boolean') ? result : result.satisfied;
                                
                                if (!isSatisfied) {
                                    allOtherRulesSatisfied = false;
                                    state.data.finalFailedRule = i;
                                    break;
                                }
                            }
                        }

                        if (!textSatisfied) {
                             return { satisfied: false, info: "Don't forget to say goodbye.", highlightRegex: /This is the end/g };
                        }
                        if (!boxSatisfied) {
                             return { satisfied: false, info: "Don't forget to check the box." };
                        }
                        if (!allOtherRulesSatisfied) {
                            const failedRuleIndex = allRules.findIndex(r => r.id === (state.data.finalFailedRule || 1)) + 1;
                            return { satisfied: false, info: `Wait... Rule ${failedRuleIndex || '?'} is no longer satisfied!` };
                        }

                        return {
                            satisfied: true,
                            info: "All done!"
                        };
                    }
                }
            ].sort((a, b) => {
                if (a.id === 50) return 1;
                if (b.id === 50) return -1;
                return a.id - b.id;
            });


            // --- Game State Variables ---
            const LOCAL_STORAGE_KEY = 'passwordGameState_v25_75rules';
            
            const createNewGameState = () => {
                const randomAtomic = atomicWords[randomInt(0, atomicWords.length - 1)];
                const riddleChoice = randomInt(0, 1) === 0 ? 1 : 2;
                const riddle = riddleChoice === 1 ? "I have cities, but no houses; forests, but no trees; and water, but no fish. What am I?" : "What has to be broken before you can use it?";
                const riddleSolution = riddleChoice === 1 ? "map" : "egg"; 
                
                const daysAgo = 91;
                const pastDate = new Date();
                pastDate.setDate(pastDate.getDate() - daysAgo);
                const pastDayName = dayNames[pastDate.getDay()];
                
                let d1, d2, exactDigitCount, digitSumTarget;
                let isAchievable = false;

                while (!isAchievable) {
                    d1 = randomInt(0, 9);
                    d2 = randomInt(0, 9);
                    while (d1 === d2) {
                        d2 = randomInt(0, 9);
                    }
                    
                    exactDigitCount = randomInt(2, 5);
                    const targetSumRange = [25, 150];

                    const availableDigits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].filter(d => d !== d1 && d !== d2);
                    const maxDigit = Math.max(...availableDigits);
                    
                    const minDigit = availableDigits.includes(1) ? 1 : Math.min(...availableDigits.filter(d => d > 0));
                    
                    const minPossibleSum = minDigit; 
                    const maxPossibleSum = maxDigit * exactDigitCount;

                    const validMin = Math.max(targetSumRange[0], minPossibleSum);
                    const validMax = Math.min(targetSumRange[1], maxPossibleSum);

                    if (validMin <= validMax) {
                        digitSumTarget = randomInt(validMin, validMax);
                        isAchievable = true;
                    }
                }
                
                return {
                    password: "",
                    activeRuleIds: [1],
                    digitSumTarget: digitSumTarget,
                    numGreaterThanTarget: randomInt(20, 60),
                    romanSumTarget: randomInt(15, 1500),
                    lengthMultipleTarget: randomInt(3, 5),
                    temperatureTarget: randomInt(40, 60),
                    exactDigitCount: exactDigitCount, 
                    consecutiveCharCount: randomInt(4, 6),
                    maxLengthTarget: randomInt(180, 250),
                    rareLetter: ['k', 'v', 'x', 'z', 'q'][randomInt(0, 4)],
                    ipOctetSum: randomInt(100, 200),
                    caesarShift: randomInt(3, 10), 
                    daysAgo: daysAgo, 
                    pastDayName: pastDayName, 
                    secretWord: secretWords[randomInt(0, secretWords.length - 1)],
                    exclamationCount: randomInt(2, 4),
                    atomicWord: randomAtomic.word, 
                    atomicSymbols: randomAtomic.symbols, 
                    sacrificedDigit1: d1, 
                    sacrificedDigit2: d2, 
                    riddle: riddle,
                    riddleSolution: riddleSolution,
                    hurricaneFired: false,
                    peteHasBeenAdded: false, 
                    peteIsAlive: true,
                    poopRulePassed: false,
                    mudEvent: {
                        nextEventTime: null,
                        isHardened: false,
                        starveTime: null
                    }
                };
            };
            
            let gameState = createNewGameState();
            let ruleStateData = {
                // --- NEW: YouTube check state ---
                youtubeCheckUrl: null,       // The last URL we checked
                youtubeCheckStatus: null,    // null | 'checking' | 'valid' | 'invalid'
                isYoutubeCheckRunning: false,
                youtubeVideoTitle: null      // Store the video title if found
                // --- END: YouTube check state ---
            }; 
            let lastTimeBasedResults = {}; 
            let isGameWon = false; 

            // --- rAF Loop State ---
            let lastLogicUpdateTime = 0;
            let animationFrameId = null;
            let ruleCleanupTimers = {}; // <-- ADDED: To track cleanup timers

            /* --- NEW: Debounce timer for text input --- */
            let inputDebounceTimer = null;


            // --- DOM Elements ---
            const passwordInput = document.getElementById('passwordInput');
            const highlighter = document.getElementById('highlighter');
            const rulesList = document.getElementById('rulesList');
            const resetButton = document.getElementById('resetButton');
            const cheatButton = document.getElementById('cheatButton');
            const finalCheckWrapper = document.getElementById('finalCheckWrapper');
            const finalCheck = document.getElementById('finalCheck');
            const ruleCounter = document.getElementById('ruleCounter'); 
            const deathMessage = document.getElementById('deathMessage'); 
            const mudReminder = document.getElementById('mudEventReminder');
            const alertOverlay = document.getElementById('alertOverlay');


            // --- Core Game Logic ---

            function loadGame() {
                const savedState = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (savedState) {
                    try {
                        const loaded = JSON.parse(savedState);
                        gameState = { ...createNewGameState(), ...loaded };
                        
                        if (!gameState.activeRuleIds || gameState.activeRuleIds.length === 0) {
                            resetGame(false); 
                            return; 
                        }
                    } catch (e) {
                        console.error("Failed to parse saved state:", e);
                        resetGame(false); 
                        return; 
                    }
                } else {
                    resetGame(false);
                    return; 
                }
                
                passwordInput.value = gameState.password;
                rulesList.innerHTML = ''; 
                
                gameState.activeRuleIds.forEach(id => {
                    const rule = allRules.find(r => r.id === id);
                    if (rule) {
                        renderRule(rule);
                    }
                });
                
                checkRulesAndReorder(false); 
                resizeTextarea();
            }

            function saveGame() {
                // Only save if the game isn't over
                if(isGameWon) return;
                gameState.password = passwordInput.value;
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(gameState));
            }

            function resetGame(reload = true) {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                lastLogicUpdateTime = 0;

                isGameWon = false;
                passwordInput.value = ""; 
                passwordInput.disabled = false;
                cheatButton.disabled = false;

                // --- NEW: Clear any pending debounce check ---
                clearTimeout(inputDebounceTimer);

                gameState = createNewGameState();
                
                ruleStateData = {
                    // --- NEW: YouTube check state ---
                    youtubeCheckUrl: null,
                    youtubeCheckStatus: null, 
                    isYoutubeCheckRunning: false,
                    youtubeVideoTitle: null
                    // --- END: YouTube check state ---
                }; 
                lastTimeBasedResults = {};
                ruleCleanupTimers = {}; // <-- ADDED: Reset the timer map
                document.getElementById('chaos').style.display = 'none';
                document.body.style.backgroundColor = 'var(--color-bg)'; 
                
                finalCheckWrapper.style.display = 'none';
                finalCheck.checked = false;
                
                deathMessage.style.display = 'none'; 
                deathMessage.classList.remove('visible', 'shaking');
                
                mudReminder.style.display = 'none';
                triggerVisualAlert('clear');
                
                saveGame(); 
                
                if (reload) {
                    loadGame();
                } else {
                    passwordInput.value = gameState.password;
                    rulesList.innerHTML = ''; 
                    renderRule(allRules.find(r => r.id === 1));
                    checkRulesAndReorder(false);
                }
                resizeTextarea();

                if (reload) {
                    animationFrameId = requestAnimationFrame(gameLoop);
                }
            }

            function renderRule(rule) {
                const li = document.createElement('li');
                li.id = `rule-${rule.id}`;
                
                li.className = 'rule broken entering'; 
                
                const stateForDescription = { game: gameState, data: ruleStateData, results: {} };
                
                const description = typeof rule.description === 'function' 
                    ? rule.description(stateForDescription) 
                    : rule.description;
                
                const displayId = allRules.findIndex(r => r.id === rule.id) + 1;
                
                li.innerHTML = `
                    <span class="rule-number">Rule ${displayId}</span>
                    <span class="rule-text">
                        ${description}
                        <span class="rule-info"></span>
                    </span>
                `;
                
                // --- FIX: Add new rules to the BOTTOM, not the top ---
                // This is the core fix. Prepend() was causing the animation
                // to calculate a 0px distance, resulting in a "teleport".
                rulesList.appendChild(li);

                li.addEventListener('animationend', () => {
                    li.classList.remove('entering');
                }, { once: true });
            }
            
            function checkRulesAndReorder(isTimeUpdate = false) {
                if (!gameState.peteIsAlive) {
                    // Only trigger death message if it's not already shown
                    if (!isGameWon) {
                        showDeathMessage("Pete has died. You must start over.");
                    }
                    return;
                }
                if (isGameWon) return; 

                const password = passwordInput.value;
                
                if (gameState.peteHasBeenAdded && !password.includes("ðŸ›") && !gameState.mudEvent.isHardened) {
                    gameState.peteIsAlive = false;
                    showDeathMessage("You deleted Pete! You must start over.");
                    return;
                }
                
                let allCurrentlySatisfied = true;
                let satisfiedCount = 0; 
                
                const allHighlightRegexes = [];

                const currentState = {
                    results: {},
                    data: ruleStateData, 
                    game: gameState     
                };
                
                // Store last known times for rules that aren't run every frame
                if(isTimeUpdate) {
                    currentState.data.lastHurricaneTime = Date.now();
                    currentState.data.lastPeteTime = Date.now();
                }

                for (const ruleId of gameState.activeRuleIds) {
                    const rule = allRules.find(r => r.id === ruleId);
                    if (!rule) continue;
                    
                    const ruleElement = document.getElementById(`rule-${rule.id}`);
                    if (!ruleElement) continue;

                    let result;
                    try {
                        // Pass 'isTimeUpdate' to check function
                        result = rule.check(password, currentState, isTimeUpdate);
                    } catch (e) {
                        console.error(`Error in rule ${rule.id}:`, e);
                        result = { satisfied: false, info: "Rule encountered an error." };
                    }

                    if (typeof result === 'boolean') {
                        result = { satisfied: result };
                    }
                    
                    currentState.results[rule.id] = result;

                    if (!result.satisfied && result.highlightRegex) {
                        allHighlightRegexes.push(result.highlightRegex);
                    }

                    const infoElement = ruleElement.querySelector('.rule-info');
                    
                    if (result.satisfied) {
                        ruleElement.classList.add('satisfied');
                        ruleElement.classList.remove('broken');
                        satisfiedCount++; 
                    } else {
                        ruleElement.classList.add('broken');
                        ruleElement.classList.remove('satisfied');
                        allCurrentlySatisfied = false; 
                    }
                    
                    if (infoElement) {
                        infoElement.textContent = result.info || '';
                    }
                    
                    if (typeof rule.description === 'function') {
                        const ruleTextElement = ruleElement.querySelector('.rule-text');
                        const description = rule.description(currentState);
                        ruleTextElement.childNodes[0].nodeValue = description + " ";
                    }
                }
                
                ruleCounter.textContent = `${satisfiedCount} / ${allRules.length} rules satisfied`;
                
                if (currentState.data.scramblePassword && !gameState.hurricaneFired) {
                    gameState.hurricaneFired = true; 
                    const scrambledPass = [...password].sort(() => 0.5 - Math.random()).join('');
                    passwordInput.value = scrambledPass; 
                    
                    // --- MODIFICATION: Must manually call saveGame() ---
                    saveGame();
                    resizeTextarea();
                    // Do NOT call onPasswordInput() as that is now just for user input
                    
                    return; 
                }
                
                updateHighlighter(password, allHighlightRegexes);

                // --- Rule Re-ordering ---
                const satisfiedRuleIds = [];
                const unsatisfiedRuleIds = [];
                const timerRuleIds = [43, 44, 56]; // Hurricane, Aftermath, Temp

                for (const ruleId of gameState.activeRuleIds) {
                    const ruleResult = currentState.results[ruleId];
                    if (ruleResult && ruleResult.satisfied) {
                        satisfiedRuleIds.push(ruleId);
                    } else {
                        unsatisfiedRuleIds.push(ruleId);
                    }
                }
                
                const brokenTimerRules = unsatisfiedRuleIds
                    .filter(id => timerRuleIds.includes(id))
                    .sort((a,b) => a - b); 
                    
                const nonTimerUnsatisfiedRules = unsatisfiedRuleIds.filter(id => !timerRuleIds.includes(id));

                nonTimerUnsatisfiedRules.sort((a, b) => a - b);
                
                // --- REVERTED SORTING as requested ---
                // Sorts satisfied rules descending (e.g., 75, 74, ... 1)
                // This places Rule 1 at the bottom of the list.
                satisfiedRuleIds.sort((a, b) => b - a); 
                // --- END CHANGE ---
                
                const orderedRuleIds = [...brokenTimerRules, ...nonTimerUnsatisfiedRules, ...satisfiedRuleIds];
                
                
                // --- FIX: Check if the order has *actually* changed ---
                const currentDomIds = Array.from(rulesList.children).map(li => parseInt(li.id.split('-')[1]));
                const orderHasChanged = JSON.stringify(orderedRuleIds) !== JSON.stringify(currentDomIds);

                // Only run the expensive FLIP animation if the order is different
                if (orderHasChanged) {
                
                    /* --- FLIP ANIMATION --- */

                    const firstPositions = {};
                    const deltas = {}; // <-- ADDED to store deltas
                    for (const ruleId of gameState.activeRuleIds) {
                        const ruleElement = document.getElementById(`rule-${ruleId}`);
                        if (ruleElement) {
                            firstPositions[ruleId] = ruleElement.getBoundingClientRect();
                        }
                    }

                    orderedRuleIds.forEach(ruleId => {
                        const ruleElement = document.getElementById(`rule-${ruleId}`);
                        if (ruleElement) {
                            rulesList.appendChild(ruleElement);
                        }
                    });

                    for (const ruleId of gameState.activeRuleIds) {
                        const ruleElement = document.getElementById(`rule-${ruleId}`);
                        if (!ruleElement || !firstPositions[ruleId]) continue;

                        const lastPosition = ruleElement.getBoundingClientRect();
                        const firstPosition = firstPositions[ruleId];

                        const deltaX = firstPosition.left - lastPosition.left;
                        const deltaY = firstPosition.top - lastPosition.top;
                        
                        deltas[ruleId] = { x: deltaX, y: deltaY }; // <-- ADDED: Store deltaY

                        // --- MODIFICATION: Removed the 'if (deltaX === 0 && deltaY === 0) continue;' check ---
                        // Now all elements, even non-moving ones, get their transform and transition explicitly set.
                        // This prevents 'teleporting' on subsequent moves.

                        ruleElement.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                        ruleElement.style.transition = 'none';
                        
                        // CRITICAL FIX: Force Reflow/Recalculation
                        ruleElement.offsetHeight; 
                    }

                    requestAnimationFrame(() => {
                        for (const ruleId of gameState.activeRuleIds) {
                            const ruleElement = document.getElementById(`rule-${ruleId}`);
                            if (!ruleElement) continue;

                            // --- NEW Z-INDEX LOGIC (FIXED) ---
                            const delta = deltas[ruleId];
                            
                            // Use a small tolerance for floating point errors
                            if (delta && delta.y > 0.1) { // Element is moving UP (making room for a satisfied rule)
                                ruleElement.style.zIndex = '10'; // Stay ON TOP
                            } else if (delta && delta.y < -0.1) { // Element is moving DOWN (it was just satisfied)
                                ruleElement.style.zIndex = '1'; // Go BEHIND
                            } else {
                                ruleElement.style.zIndex = '5'; // Default (not moving)
                            }
                            // --- END NEW LOGIC ---
                            
                            // --- FIX: Cancel any pending cleanup from the *previous* animation ---
                            if (ruleCleanupTimers[ruleId]) {
                                clearTimeout(ruleCleanupTimers[ruleId]);
                            }
                            // --- END FIX ---

                            // Apply the transition and play the animation
                            ruleElement.style.transition = `transform var(--m3-duration-fluid-settle) var(--m3-ease-physics-spring)`;
                            ruleElement.style.transform = '';

                            // --- FIX: Store the new cleanup timer ID ---
                            // 'transitionend' won't fire if the delta is 0,
                            // which leaves z-index and transition properties "stuck" on the element,
                            // breaking the *next* animation.
                            ruleCleanupTimers[ruleId] = setTimeout(() => {
                                if (ruleElement) { // Ensure element still exists
                                    ruleElement.style.transition = '';
                                    ruleElement.style.zIndex = '';
                                }
                                delete ruleCleanupTimers[ruleId]; // Clean up the timer map
                            }, 500); // 500ms must match --m3-duration-fluid-settle
                        }
                    });
                    
                    /* --- END FLIP ANIMATION --- */
                
                } // --- END FIX: End of orderHasChanged check ---


                // --- Rule Progression Logic (Only if not a time update) ---
                if (allCurrentlySatisfied && !isTimeUpdate) {
                    const lastRuleId = gameState.activeRuleIds[gameState.activeRuleIds.length - 1];
                    const lastRuleIndex = allRules.findIndex(r => r.id === lastRuleId);
                    
                    if (lastRuleIndex < allRules.length - 1) {
                        const nextRule = allRules[lastRuleIndex + 1];
                        
                        if (nextRule && !gameState.activeRuleIds.includes(nextRule.id)) {
                            gameState.activeRuleIds.push(nextRule.id);
                            renderRule(nextRule); 
                            
                            // --- FIX: Must call checkRulesAndReorder immediately after render ---
                            // This ensures the new rule is immediately processed and animated
                            // (the 'orderHasChanged' check will catch it)
                            checkRulesAndReorder(false); 
                        }
                    } else if (gameState.activeRuleIds.length === allRules.length) {
                        const finalRuleResult = currentState.results[50];
                        if (finalRuleResult && finalRuleResult.satisfied) {
                            showWinState();
                        }
                    }
                }
            }
            
            // --- MODIFIED: This function NO LONGER runs game logic ---
            function onPasswordInput() {
                // These are cheap, run them instantly
                resizeTextarea();
                saveGame(); 

                // --- REMOVED checkRulesAndReorder(false) ---
                // As requested, the game logic will NO LONGER update on input.
                // It will only update in the gameLoop (synced to refresh rate).
            }

            function onTimeUpdate() {
                if (isGameWon) return; 
                
                const password = passwordInput.value;
                let hasTimeRuleChanged = false; // Flag to see if we need to re-render
                let isDimmed = false;
                
                const timeCheckState = {
                    results: {},
                    data: ruleStateData,
                    game: gameState
                };

                // 1. Check *only* time-sensitive rules
                for (const ruleId of timeSensitiveRuleIds) {
                    if (!gameState.activeRuleIds.includes(ruleId)) continue; 
                    
                    const rule = allRules.find(r => r.id === ruleId);
                    if (!rule) continue;
                    
                    const result = rule.check(password, timeCheckState, true); // Pass true for isTimeUpdate
                    const isSatisfied = (typeof result === 'boolean') ? result : result.satisfied;
                    
                    if (lastTimeBasedResults[ruleId] !== isSatisfied) {
                        hasTimeRuleChanged = true;
                    }
                    lastTimeBasedResults[ruleId] = isSatisfied;

                    // Special checks for timer-based rules
                    if ((ruleId === 43 && !isSatisfied && !gameState.hurricaneFired) ||
                        (ruleId === 44 && !isSatisfied && gameState.peteIsAlive) ||
                        (ruleId === 56) ) {
                        hasTimeRuleChanged = true;
                    }
                    
                    if (ruleId === 44 && !isSatisfied && gameState.peteIsAlive) {
                        isDimmed = true;
                    }
                }
                
                if (!gameState.peteIsAlive) {
                    hasTimeRuleChanged = true;
                }
                
                // 2. Check Mud Event Logic
                if (gameState.peteHasBeenAdded && !isGameWon) {
                    const now = Date.now();
                    
                    if (!gameState.mudEvent.isHardened && gameState.mudEvent.nextEventTime && now >= gameState.mudEvent.nextEventTime) {
                        
                        if (password.includes('ðŸ’©ðŸ›ðŸ’©')) {
                            gameState.mudEvent.isHardened = true;
                            gameState.mudEvent.starveTime = now + 30000;
                            
                            passwordInput.value = passwordInput.value.replace(/ðŸ’©ðŸ›ðŸ’©/g, 'ðŸª¨ðŸ›ðŸª¨');
                            
                            // Call main update logic *immediately* when mud hardens
                            checkRulesAndReorder(false); 
                            resizeTextarea();
                            saveGame();
                            return; // Exit early
                        } else {
                            gameState.mudEvent.nextEventTime = now + 30000;
                        }
                    }

                    if (gameState.mudEvent.isHardened) {
                        const isPeteSafe = password.includes('ðŸ’©ðŸ›ðŸ’©');

                        if (isPeteSafe) {
                            gameState.mudEvent.isHardened = false;
                            gameState.mudEvent.starveTime = null;
                            gameState.mudEvent.nextEventTime = Date.now() + randomInt(90000, 300000);
                            mudReminder.style.display = 'none';
                            saveGame();
                        } else {
                            const secondsLeft = Math.ceil((gameState.mudEvent.starveTime - now) / 1000);

                            if (secondsLeft > 0) {
                                mudReminder.innerHTML = `
                                    The mud has hardened! Change ðŸª¨ back to ðŸ’© to feed Pete!
                                    <strong>Time left: ${secondsLeft}s</strong>
                                `;
                                mudReminder.style.display = 'block';
                                isDimmed = true;
                                hasTimeRuleChanged = true; // Need to update the info text
                            } else {
                                gameState.peteIsAlive = false; 
                                mudReminder.style.display = 'none';
                            }
                        }
                    } else {
                        mudReminder.style.display = 'none';
                    }
                }
                
                // 3. Apply visual alerts
                if (isDimmed) {
                    triggerVisualAlert('dim');
                } else {
                    // Only clear if not *already* flashing (let flashes finish)
                    if (!alertOverlay.classList.contains('flashing')) {
                         triggerVisualAlert('clear');
                    }
                }
                
                // 4. If any time rule changed, run a *time-only* update
                if (hasTimeRuleChanged || (ruleStateData && ruleStateData.scramblePassword)) {
                    checkRulesAndReorder(true); // `true` means only update time rules, don't progress
                }
            }

            // --- rAF-based Game Loop ---
            function gameLoop(timestamp) {
                if (isGameWon) {
                    animationFrameId = null;
                    return;
                }

                // --- MODIFIED: Main logic now runs every frame ---
                // This is the update "synced with refresh rate" you asked for.
                // This will check all rules and run animations on every frame.
                // We pass 'false' for 'isTimeUpdate'
                checkRulesAndReorder(false);


                // --- LOGIC THAT RUNS ONCE PER SECOND ---
                if (timestamp - lastLogicUpdateTime >= 1000) {
                    lastLogicUpdateTime = timestamp;
                    onTimeUpdate();
                }
                // --- END SECOND LOGIC ---

                animationFrameId = requestAnimationFrame(gameLoop);
            }
            
            function advanceGame() {
                if (isGameWon) return;

                for (const ruleId of gameState.activeRuleIds) {
                     const ruleElement = document.getElementById(`rule-${ruleId}`);
                     if (ruleElement && ruleElement.classList.contains('broken')) {
                         
                         if (ruleId === 43) {
                             ruleStateData.scramblePassword = true;
                         }
                         if (ruleId === 44 && gameState.peteIsAlive) {
                             passwordInput.value += "ðŸ’©ðŸ›ðŸ’©";
                         }
                         if (ruleId === 50) {
                             passwordInput.value += "This is the end";
                             finalCheck.checked = true;
                         }
                     }
                }
                
                const lastRuleId = gameState.activeRuleIds[gameState.activeRuleIds.length - 1];
                const lastRuleIndex = allRules.findIndex(r => r.id === lastRuleId);
                
                if (lastRuleIndex < allRules.length - 1) {
                    const nextRule = allRules[lastRuleIndex + 1];
                    if (nextRule && !gameState.activeRuleIds.includes(nextRule.id)) {
                        gameState.activeRuleIds.push(nextRule.id);
                        renderRule(nextRule);
                    }
                }
                
                // --- FIX: Must call checkRulesAndReorder manually ---
                // (since renderRule no longer calls it)
                checkRulesAndReorder(false);
            }

            function showWinState() {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                isGameWon = true;
                triggerVisualAlert('clear');
                rulesList.innerHTML = `
                    <li class="win-message">
                        ðŸŽ‰ Congrats! ðŸŽ‰
                        <div style="font-size: 1.25rem; font-weight: normal; margin-top: 1rem;">This is your password:</div>
                        <div class="final-password-wrapper">
                            ${passwordInput.value}
                        </div>
                    </li>`;
                finalCheckWrapper.style.display = 'none';
                ruleCounter.style.display = 'none';
                passwordInput.disabled = true;
                cheatButton.disabled = true;
            }
            
            function showDeathMessage(message) {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }

                isGameWon = true;
                triggerVisualAlert('clear');
                deathMessage.textContent = message;
                deathMessage.style.display = 'block';

                /* Trigger DeathMessage Animation */
                requestAnimationFrame(() => {
                    deathMessage.classList.add('visible');
                });

                // Shake *after* fade-in (200ms = --m3-duration-short)
                setTimeout(() => {
                    deathMessage.classList.add('shaking');
                }, 200); 

                passwordInput.disabled = true;
                cheatButton.disabled = true;
            }

        
            // --- Event Listeners ---
            passwordInput.addEventListener('input', onPasswordInput); // <-- MODIFIED (no longer runs logic)
            passwordInput.addEventListener('scroll', syncScroll);
            
            /* --- Reset Button Logic --- */
            let resetHoldTimer = null;
            let isHoldingReset = false;
            
            const startHold = (e) => {
                e.preventDefault(); // Prevent text selection
                isHoldingReset = true;
                resetButton.classList.add('holding');
                resetHoldTimer = setTimeout(() => {
                    if (isHoldingReset) {
                        resetGame(true);
                        // Reset state after firing
                        isHoldingReset = false;
                        resetButton.classList.remove('holding');
                        clearTimeout(resetHoldTimer);
                    }
                }, 2000); // 2-second timer
            };
            
            const endHold = (e) => {
                e.preventDefault();
                isHoldingReset = false;
                resetButton.classList.remove('holding');
                clearTimeout(resetHoldTimer);
            };
            
            // Mouse events
            resetButton.addEventListener('mousedown', startHold);
            resetButton.addEventListener('mouseup', endHold);
            resetButton.addEventListener('mouseleave', endHold);
            
            // Touch events for mobile
            resetButton.addEventListener('touchstart', startHold);
            resetButton.addEventListener('touchend', endHold);
            
            
            finalCheck.addEventListener('change', () => {
                // Checkbox changes should be instant, no debounce
                // The checkRulesAndReorder in the gameLoop will pick this up on its next frame
                saveGame();
            });
            
            cheatButton.addEventListener('click', () => {
                const SECRET_CODE = "test";
                const input = prompt("Enter the advance code to proceed:");
                
                if (input && input.toLowerCase() === SECRET_CODE) {
                    advanceGame();
                } else if (input !== null && input !== "") {
                    // Replaced alert with a non-blocking console log
                    console.warn("Incorrect advance code.");
                }
            });

            // --- Initial Game Load ---
            loadGame();
            
            // --- Real-time loop (rAF) ---
            animationFrameId = requestAnimationFrame(gameLoop);

        });
    </script>

</body>
</html>
